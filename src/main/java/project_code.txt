

===== .\project_code.txt =====



===== .\com\divya\linkedinclone\LinkedinApplication.java =====

package com.divya.linkedinclone;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;
@SpringBootApplication
@EnableJpaAuditing // Enable JPA auditing
public class LinkedinApplication {

	public static void main(String[] args) {
		SpringApplication.run(LinkedinApplication.class, args);
	}

}

===== .\config\GlobalExceptionHandler.java =====

package com.divya.linkedinclone.config;
import com.divya.linkedinclone.exception.CommentNotFoundException;
import com.divya.linkedinclone.exception.ProfileNotFoundException;
import com.divya.linkedinclone.exception.PostNotFoundException;

import com.divya.linkedinclone.exception.UserNotFoundException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

import java.util.HashMap;
import java.util.Map;

@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(ProfileNotFoundException.class)
    public ResponseEntity<?> handleProfileNotFoundException(ProfileNotFoundException ex) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(Map.of("error", ex.getMessage()));
    }

    @ExceptionHandler(UserNotFoundException.class)
    public ResponseEntity<?> handleUserNotFoundException(UserNotFoundException ex) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(Map.of("error", ex.getMessage()));
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<?> handleValidationExceptions(MethodArgumentNotValidException ex) {
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getFieldErrors().forEach(error ->
                errors.put(error.getField(), error.getDefaultMessage()));
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errors);
    }

    @ExceptionHandler(RuntimeException.class)
    public ResponseEntity<?> handleRuntimeException(RuntimeException ex) {
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(Map.of("error", ex.getMessage()));
    }

    @ExceptionHandler(PostNotFoundException.class)
    public ResponseEntity<?> handlePostNotFoundException(PostNotFoundException ex) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(Map.of("error", ex.getMessage()));
    }

    @ExceptionHandler(CommentNotFoundException.class)
    public ResponseEntity<?> handleCommentNotFoundException(CommentNotFoundException ex) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(Map.of("error", ex.getMessage()));
    }

}

===== .\config\SecurityConfig.java =====

package com.divya.linkedinclone.config;

import jakarta.servlet.http.HttpServletResponse;
import com.divya.linkedinclone.filter.JwtRequestFilter;
import com.divya.linkedinclone.service.CustomUserDetailsService;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    private final JwtRequestFilter jwtRequestFilter;
    private final CustomUserDetailsService userDetailsService;

    public SecurityConfig(JwtRequestFilter jwtRequestFilter, CustomUserDetailsService userDetailsService) {
        this.jwtRequestFilter = jwtRequestFilter;
        this.userDetailsService = userDetailsService;
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                .csrf(csrf -> csrf.disable())
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/uploads/**").permitAll()
                        .requestMatchers("/api/users/register", "/api/users/login","/api/users/verify", "/api/users/forgot-password", "/api/users/reset-password/**").permitAll()
                        .requestMatchers("/api/admin/register").permitAll() // Add this line
                        .requestMatchers("/api/admin/login").permitAll()
                        .requestMatchers("/api/admin/**").hasRole("ADMIN")
                        .requestMatchers("/api/user/**").hasAnyRole("USER", "ADMIN")
                        .anyRequest().authenticated()
                )
                .sessionManagement(session -> session
                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                )
                .addFilterBefore(jwtRequestFilter, UsernamePasswordAuthenticationFilter.class)
                .exceptionHandling(exception -> exception
                        .authenticationEntryPoint((request, response, authException) -> {
                            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
                            response.getWriter().write("{\"message\":\"Unauthorized access\"}");
                        })
                        .accessDeniedHandler((request, response, accessDeniedException) -> {
                            response.setStatus(HttpServletResponse.SC_FORBIDDEN);
                            response.getWriter().write("{\"message\":\"Access denied\"}");
                        })
                );
        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authenticationConfiguration) throws Exception {
        return authenticationConfiguration.getAuthenticationManager();
    }

    @Bean
    public DaoAuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder());
        return authProvider;
    }

}

===== .\config\WebConfig.java =====

package com.divya.linkedinclone.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Value("${upload.directory}")
    private String uploadDirectory;

    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/uploads/**")
                .addResourceLocations("file:" + uploadDirectory + "/");
    }
}

===== .\controller\AdminController.java =====

// .\controller\AdminController.java
package com.divya.linkedinclone.controller;

import com.divya.linkedinclone.dto.AdminLoginRequest;
import com.divya.linkedinclone.dto.AdminRegistrationRequest;
import com.divya.linkedinclone.dto.AdminResponse;
import com.divya.linkedinclone.entity.Admin;
import com.divya.linkedinclone.service.AdminService;
import com.divya.linkedinclone.service.UserService;
import com.divya.linkedinclone.util.JwtUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.web.bind.annotation.*;
import java.util.HashMap;
import java.util.List;
import org.springframework.security.core.Authentication;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.authentication.BadCredentialsException;
import java.util.Map;
import org.springframework.security.core.userdetails.UserDetails;


@RestController
@RequestMapping("/api/admin")
public class AdminController {

    @Autowired
    private AdminService adminService;

    @Autowired
    private UserService userService;

    @Autowired
    private JwtUtil jwtUtil;

    @Autowired
    private AuthenticationManager authenticationManager;


    @PostMapping("/register")
    public ResponseEntity<?> registerAdmin(@RequestBody AdminRegistrationRequest registrationRequest) {
        try {
            Admin admin = adminService.registerAdmin(registrationRequest);
            AdminResponse response = new AdminResponse(
                    admin.getId(),
                    admin.getUsername(),
                    admin.getEmail(),
                    admin.getRole(),
                    admin.getIsActive(),
                    admin.getCreatedAt(),
                    admin.getUpdatedAt()
            );
            return ResponseEntity.ok(response);
        } catch (RuntimeException e) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(Map.of("error", e.getMessage()));
        }
    }

    @PostMapping("/login")
    public ResponseEntity<?> loginAdmin(@RequestBody AdminLoginRequest loginRequest) {
        try {
            // Use the admin-specific authentication
            Authentication authentication = authenticationManager.authenticate(
                    new UsernamePasswordAuthenticationToken(
                            loginRequest.getUsername(),
                            loginRequest.getPassword()
                    )
            );

            // Generate token
            UserDetails userDetails = (UserDetails) authentication.getPrincipal();
            final String jwt = jwtUtil.generateToken(userDetails);

            Map<String, Object> response = new HashMap<>();
            response.put("token", jwt);
            response.put("role", "ADMIN");
            return ResponseEntity.ok(response);
        } catch (BadCredentialsException e) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("Invalid username or password");
        }
    }
    @GetMapping("/users")
    public ResponseEntity<?> getAllUsers() {
        try {
            // This should be implemented in UserService to return simplified user data
            List<Map<String, Object>> users = userService.getAllUsersForAdmin();
            return ResponseEntity.ok(users);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of("error", "Failed to fetch users"));
        }
    }

    @GetMapping("/users/{userId}")
    public ResponseEntity<?> getUserById(@PathVariable Long userId) {
        try {
            Map<String, Object> user = userService.getUserByIdForAdmin(userId);
            return ResponseEntity.ok(user);
        } catch (RuntimeException e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                    .body(Map.of("message", e.getMessage()));
        }
    }

    @DeleteMapping("/users/{userId}")
    public ResponseEntity<?> deleteUser(@PathVariable Long userId) {
        try {
            userService.deleteUserByAdmin(userId);
            return ResponseEntity.ok(Map.of("message", "User deleted successfully"));
        } catch (RuntimeException e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                    .body(Map.of("message", e.getMessage()));
        }
    }
}

===== .\controller\CommentController.java =====

package com.divya.linkedinclone.controller;

import com.divya.linkedinclone.service.CommentService;
import com.divya.linkedinclone.dto.CommentResponse;
import com.divya.linkedinclone.entity.Comment;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import java.util.Map;
import java.util.List;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/comments")
public class CommentController {

    @Autowired
    private CommentService commentService;

    @PostMapping("/{postId}")
    public ResponseEntity<CommentResponse> addComment(
            @PathVariable Long postId,
            @RequestParam Long userId,
            @RequestBody Map<String, String> request
    ) {
        String content = request.get("content");
        Comment comment = commentService.addComment(postId, userId, content);
        CommentResponse response = new CommentResponse(comment);
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    @GetMapping("/{postId}")
    public ResponseEntity<List<CommentResponse>> getCommentsByPostId(@PathVariable Long postId) {
        List<Comment> comments = commentService.getCommentsByPostId(postId);
        List<CommentResponse> responses = comments.stream()
                .map(CommentResponse::new)
                .collect(Collectors.toList());
        return ResponseEntity.ok(responses);
    }

    @DeleteMapping("/{commentId}")
    public ResponseEntity<?> deleteComment(@PathVariable Long commentId) {
        try {
            commentService.deleteComment(commentId);
            return ResponseEntity.ok("Comment deleted successfully");
        } catch (RuntimeException e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(Map.of("error", e.getMessage()));
        }
    }
}

===== .\controller\ConnectionController.java =====

package com.divya.linkedinclone.controller;

import com.divya.linkedinclone.entity.User;
import com.divya.linkedinclone.service.ConnectionService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import com.divya.linkedinclone.entity.Connection;
import java.util.List;
import java.util.Map;
import com.divya.linkedinclone.dto.ConnectionResponse;

@RestController
@RequestMapping("/api/connections")
public class ConnectionController {

    @Autowired
    private ConnectionService connectionService;

    @PostMapping("/request")
    public ResponseEntity<?> sendConnectionRequest(@RequestBody Map<String, Long> request) {
        Long senderId = request.get("senderId");
        Long receiverId = request.get("receiverId");
        String message = connectionService.sendConnectionRequest(senderId, receiverId);
        return ResponseEntity.ok(Map.of("message", message));
    }

    @PostMapping("/accept")
    public ResponseEntity<?> acceptConnectionRequest(@RequestBody Map<String, Long> request) {
        Long receiverId = request.get("receiverId");
        Long senderId = request.get("senderId");
        String message = connectionService.acceptConnectionRequest(receiverId, senderId);
        return ResponseEntity.ok(Map.of("message", message));
    }

    @PostMapping("/reject")
    public ResponseEntity<?> rejectConnectionRequest(@RequestBody Map<String, Long> request) {
        Long receiverId = request.get("receiverId");
        Long senderId = request.get("senderId");
        String message = connectionService.rejectConnectionRequest(receiverId, senderId);
        return ResponseEntity.ok(Map.of("message", message));
    }

    @DeleteMapping("/cancel")
    public ResponseEntity<?> cancelConnectionRequest(@RequestBody Map<String, Long> request) {
        Long senderId = request.get("senderId");
        Long receiverId = request.get("receiverId");
        String message = connectionService.cancelConnectionRequest(senderId, receiverId);
        return ResponseEntity.ok(Map.of("message", message));
    }

    @DeleteMapping("/remove")
    public ResponseEntity<?> removeConnection(@RequestBody Map<String, Long> request) {
        Long userId = request.get("userId");
        Long connectionId = request.get("connectionId");
        String message = connectionService.removeConnection(userId, connectionId);
        return ResponseEntity.ok(Map.of("message", message));
    }

    @GetMapping("/pending")
    public ResponseEntity<?> getPendingRequests(@RequestParam Long userId) {
        List<ConnectionResponse> pendingRequests = connectionService.getPendingRequests(userId);
        return ResponseEntity.ok(Map.of("pendingRequests", pendingRequests));
    }

    @GetMapping("/all")
    public ResponseEntity<?> getAllConnections(@RequestParam Long userId) {
        List<ConnectionResponse> connections = connectionService.getAllConnections(userId);
        return ResponseEntity.ok(Map.of("connections", connections));
    }

    @GetMapping("/mutual")
    public ResponseEntity<?> getMutualConnections(@RequestParam Long userId, @RequestParam Long otherUserId) {
        List<ConnectionResponse> mutualConnections = connectionService.getMutualConnections(userId, otherUserId);
        return ResponseEntity.ok(Map.of("mutualConnections", mutualConnections));
    }
}

===== .\controller\FollowController.java =====

package com.divya.linkedinclone.controller;

import com.divya.linkedinclone.service.FollowService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/connections")
public class FollowController {

    @Autowired
    private FollowService followService;

    @PostMapping("/follow/{userId}")
    public ResponseEntity<?> followUser(@PathVariable Long userId, @RequestParam Long followerId) {
        String message = followService.followUser(followerId, userId);
        return ResponseEntity.ok(Map.of("message", message));
    }

    @DeleteMapping("/unfollow/{userId}")
    public ResponseEntity<?> unfollowUser(@PathVariable Long userId, @RequestParam Long followerId) {
        String message = followService.unfollowUser(followerId, userId);
        return ResponseEntity.ok(Map.of("message", message));
    }

    @GetMapping("/followers/{userId}")
    public ResponseEntity<?> getFollowers(@PathVariable Long userId) {
        List<Long> followers = followService.getFollowers(userId);
        return ResponseEntity.ok(Map.of("followers", followers));
    }

    @GetMapping("/following/{userId}")
    public ResponseEntity<?> getFollowing(@PathVariable Long userId) {
        List<Long> following = followService.getFollowing(userId);
        return ResponseEntity.ok(Map.of("following", following));
    }
}

===== .\controller\LikeController.java =====

package com.divya.linkedinclone.controller;

import com.divya.linkedinclone.entity.Like;
import com.divya.linkedinclone.service.LikeService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import com.divya.linkedinclone.dto.LikeResponse;
import java.util.Map; // Import for Map
import com.divya.linkedinclone.exception.PostNotFoundException; // Import for PostNotFoundException
@RestController
@RequestMapping("/api/likes")
public class LikeController {

    @Autowired
    private LikeService likeService;

    @PostMapping("/{postId}")
    public ResponseEntity<LikeResponse> toggleLike(
            @PathVariable Long postId,
            @RequestParam Long userId
    ) {
        LikeResponse response = likeService.toggleLike(postId, userId);
        return ResponseEntity.ok(response);
    }

    @GetMapping("/{postId}")
    public ResponseEntity<?> getLikeCount(@PathVariable Long postId) {
        try {
            Long likeCount = likeService.getLikeCount(postId);
            return ResponseEntity.ok(Map.of("postId", postId, "likeCount", likeCount));
        } catch (PostNotFoundException e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(Map.of("error", e.getMessage()));
        }
    }
}

===== .\controller\MessageController.java =====

package com.divya.linkedinclone.controller;

import com.divya.linkedinclone.entity.Message; // Add this import
import com.divya.linkedinclone.dto.MessageResponse;
import com.divya.linkedinclone.service.MessageService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/messages")
public class MessageController {

    @Autowired
    private MessageService messageService;

    @PostMapping("/send")
    public ResponseEntity<?> sendMessage(@RequestBody Map<String, Object> request) {
        Long senderId = Long.valueOf(request.get("senderId").toString());
        Long receiverId = Long.valueOf(request.get("receiverId").toString());
        String message = request.get("message").toString(); // Changed from "content" to "message"

        // Call the service method and store the result in a variable
        Message sentMessage = messageService.sendMessage(senderId, receiverId, message);

        // Convert the Message entity to a MessageResponse DTO
        MessageResponse response = new MessageResponse(
                sentMessage.getId(),
                sentMessage.getSender().getId(),
                sentMessage.getReceiver().getId(),
                sentMessage.getMessage(), // Changed from "getContent" to "getMessage"
                sentMessage.getSentAt()
        );

        return ResponseEntity.ok(Map.of(
                "message", "Message sent successfully",
                "messageId", response.getId() // Use the correct variable name
        ));
    }

    @GetMapping("/conversation/{userId1}/{userId2}")
    public ResponseEntity<List<MessageResponse>> getConversation(@PathVariable Long userId1, @PathVariable Long userId2) {
        List<MessageResponse> messages = messageService.getConversation(userId1, userId2);
        return ResponseEntity.ok(messages);
    }

    @GetMapping("/conversations/{userId}")
    public ResponseEntity<List<MessageResponse>> getAllConversations(@PathVariable Long userId) {
        List<MessageResponse> conversations = messageService.getAllConversations(userId);
        return ResponseEntity.ok(conversations);
    }
}

===== .\controller\NotificationController.java =====

package com.divya.linkedinclone.controller;

import com.divya.linkedinclone.entity.Notification;
import com.divya.linkedinclone.service.NotificationService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import java.util.Map;
import java.util.List;
import com.divya.linkedinclone.dto.NotificationResponse;

@RestController
@RequestMapping("/api/notifications")
public class NotificationController {

    @Autowired
    private NotificationService notificationService;

    // Get all unread notifications for a user
    @GetMapping("/unread")
    public ResponseEntity<?> getUnreadNotifications(@RequestParam Long userId) {
        List<NotificationResponse> unreadNotifications = notificationService.getUnreadNotifications(userId);
        return ResponseEntity.ok(Map.of("unreadNotifications", unreadNotifications));
    }

    // Get all notifications for a user
    @GetMapping("/all")
    public ResponseEntity<?> getAllNotifications(@RequestParam Long userId) {
        List<NotificationResponse> allNotifications = notificationService.getAllNotifications(userId);
        return ResponseEntity.ok(Map.of("allNotifications", allNotifications));
    }

    // Mark a notification as read
    @PostMapping("/mark-as-read/{notificationId}")
    public ResponseEntity<?> markNotificationAsRead(@PathVariable Long notificationId) {
        notificationService.markNotificationAsRead(notificationId);
        return ResponseEntity.ok(Map.of("message", "Notification marked as read."));
    }
}

===== .\controller\PostController.java =====

package com.divya.linkedinclone.controller;

import com.divya.linkedinclone.dto.CreatePostRequest;
import com.divya.linkedinclone.dto.PostResponse;
import com.divya.linkedinclone.entity.Post;
import com.divya.linkedinclone.service.PostService;
import org.springframework.http.HttpStatus;
import org.springframework.web.multipart.MultipartFile;
import java.util.Map;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.io.IOException;
import java.util.List;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/posts")
public class PostController {

    @Autowired
    private PostService postService;

    // Create a new post
    @PostMapping
    public ResponseEntity<?> createPost(@RequestBody CreatePostRequest createPostRequest) {
        try {
            Post createdPost = postService.createPost(createPostRequest.getUserId(), createPostRequest.getContent());
            return ResponseEntity.status(HttpStatus.CREATED).body(new PostResponse(createdPost));
        } catch (RuntimeException e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(Map.of("error", e.getMessage()));
        }
    }

    // Create a post with an image
    @PostMapping("/image")
    public ResponseEntity<?> createPostWithImage(
            @RequestParam("userId") Long userId,
            @RequestParam("content") String content,
            @RequestParam("image") MultipartFile image) {
        try {
            Post createdPost = postService.createPostWithImage(userId, content, image);
            return ResponseEntity.status(HttpStatus.CREATED).body(new PostResponse(createdPost));
        } catch (RuntimeException e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(Map.of("error", e.getMessage()));
        } catch (IOException e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(Map.of("error", "Failed to upload image"));
        }
    }

    // Get all posts by a user
    @GetMapping("/users/{userId}/posts")
    public ResponseEntity<?> getPostsByUserId(@PathVariable Long userId) {
        try {
            List<Post> posts = postService.getPostsByUserId(userId);
            List<PostResponse> postResponses = posts.stream()
                    .map(PostResponse::new)
                    .collect(Collectors.toList());
            return ResponseEntity.ok(postResponses);
        } catch (RuntimeException e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(Map.of("error", e.getMessage()));
        }
    }

    // Get a specific post by ID
    @GetMapping("/{postId}")
    public ResponseEntity<?> getPostById(@PathVariable Long postId) {
        try {
            Post post = postService.getPostById(postId);
            return ResponseEntity.ok(new PostResponse(post));
        } catch (RuntimeException e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(Map.of("error", e.getMessage()));
        }
    }

    // Get all posts
    @GetMapping
    public ResponseEntity<List<PostResponse>> getAllPosts() {
        List<Post> posts = postService.getAllPosts();
        List<PostResponse> postResponses = posts.stream()
                .map(PostResponse::new)
                .collect(Collectors.toList());
        return ResponseEntity.ok(postResponses);
    }

    // Update a post
    @PutMapping("/{postId}")
    public ResponseEntity<?> updatePost(@PathVariable Long postId, @RequestBody Map<String, String> request) {
        try {
            String newContent = request.get("content"); // Get the new content from the request body
            Post updatedPost = postService.updatePost(postId, newContent);
            return ResponseEntity.ok(new PostResponse(updatedPost));
        } catch (RuntimeException e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(Map.of("error", e.getMessage()));
        }
    }

    // Delete a post by ID
    @DeleteMapping("/{postId}")
    public ResponseEntity<?> deletePost(@PathVariable Long postId) {
        try {
            postService.deletePost(postId);
            return ResponseEntity.ok(Map.of("message", "Post deleted successfully!"));
        } catch (RuntimeException e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(Map.of("error", e.getMessage()));
        }
    }
}

===== .\controller\ProfileController.java =====

package com.divya.linkedinclone.controller;

import java.util.Optional;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.springframework.http.HttpStatus;
import com.divya.linkedinclone.entity.Profile;
import com.divya.linkedinclone.entity.User;
import com.divya.linkedinclone.exception.UserNotFoundException;
import com.divya.linkedinclone.repository.ProfileRepository;
import com.divya.linkedinclone.service.ProfileService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import com.divya.linkedinclone.util.JwtUtil;
import org.springframework.web.bind.annotation.*;
import com.divya.linkedinclone.repository.UserRepository;
@RestController
@RequestMapping("/api/profiles")
public class ProfileController {

    @Autowired
    private ProfileService profileService;

    @Autowired
    private JwtUtil jwtUtil;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private ProfileRepository profileRepository; // Autowire ProfileRepository

    // Create or update a profile
    @PostMapping("/{userId}")
    public ResponseEntity<?> createOrUpdateProfile(
            @PathVariable Long userId,
            @RequestBody Profile profile,
            @RequestHeader(value = "Authorization", required = false) String authHeader) {

        // Your existing logic from both methods combined
        if (authHeader != null) {
            // Authorization check logic from second method
            String token = authHeader.substring(7);
            String email = jwtUtil.extractUsername(token);
            User requestingUser = userRepository.findByEmail(email)
                    .orElseThrow(() -> new UserNotFoundException("User not found"));

            if (!requestingUser.getId().equals(userId)) {
                boolean isAdmin = requestingUser.getRoles().contains("ADMIN");
                if (!isAdmin) {
                    return ResponseEntity.status(HttpStatus.FORBIDDEN)
                            .body(Map.of("message", "You can only edit your own profile."));
                }
            }
        }

        Profile savedProfile = profileService.createOrUpdateProfile(userId, profile);
        return ResponseEntity.ok(savedProfile);
    }
    // Get profile by user ID
    @GetMapping("/{userId}")
    public ResponseEntity<?> getProfileByUserId(@PathVariable Long userId) {
        Profile profile = profileService.getProfileByUserId(userId);
        Map<String, Object> response = new HashMap<>();
        response.put("id", profile.getId());
        response.put("user", Map.of(
                "id", profile.getUser().getId(),
                "name", profile.getUser().getName(),
                "email", profile.getUser().getEmail()
        ));
        response.put("bio", profile.getBio());
        response.put("profilePicture", profile.getProfilePicture());
        response.put("skills", profile.getSkills());
        response.put("experience", profile.getExperience());
        response.put("education", profile.getEducation());
        response.put("location", profile.getLocation());
        response.put("website", profile.getWebsite());
        return ResponseEntity.ok(response);
    }

    // Get all profiles
    @GetMapping
    public ResponseEntity<List<Profile>> getAllProfiles() {
        List<Profile> profiles = profileRepository.findAll();
        return ResponseEntity.ok(profiles);
    }

    // Update a profile by ID
    @PutMapping("/{id}")
    public ResponseEntity<?> updateProfile(@PathVariable Long id, @RequestBody Profile updatedProfile) {
        // Check if the profile exists
        Optional<Profile> optionalProfile = profileRepository.findById(id);

        if (optionalProfile.isPresent()) {
            // Update the existing profile
            Profile profile = optionalProfile.get();
            profile.setBio(updatedProfile.getBio());
            profile.setProfilePicture(updatedProfile.getProfilePicture());
            profile.setSkills(updatedProfile.getSkills());
            profile.setExperience(updatedProfile.getExperience());
            profile.setEducation(updatedProfile.getEducation());
            profile.setLocation(updatedProfile.getLocation());
            profile.setWebsite(updatedProfile.getWebsite());

            // Save the updated profile
            Profile savedProfile = profileRepository.save(profile);
            return ResponseEntity.ok(savedProfile);
        } else {
            // Return a 404 Not Found response if the profile doesn't exist
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(Map.of("error", "Profile not found with id: " + id));
        }
    }

    // Delete a profile by ID
    @DeleteMapping("/{id}")
    public ResponseEntity<?> deleteProfile(@PathVariable Long id) {
        profileService.deleteProfile(id);
        return ResponseEntity.ok(Map.of("message", "Profile deleted successfully"));
    }


}

===== .\controller\UserController.java =====

package com.divya.linkedinclone.controller;

import java.util.HashMap;
import java.util.Map;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import com.divya.linkedinclone.dto.LoginRequest;
import com.divya.linkedinclone.dto.UserRegistrationRequest;
import com.divya.linkedinclone.repository.UserRepository;
import java.util.List;
import com.divya.linkedinclone.dto.ForgotPasswordRequest;
import com.divya.linkedinclone.dto.ResetPasswordRequest;
import com.divya.linkedinclone.exception.UserNotFoundException;

import com.divya.linkedinclone.entity.User;
import com.divya.linkedinclone.service.UserService;
import com.divya.linkedinclone.util.JwtUtil;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.*;
import org.springframework.security.crypto.password.PasswordEncoder;
@RestController
@RequestMapping("/api/users")
public class UserController {

    @Autowired
    private UserService userService;

    @Autowired
    private AuthenticationManager authenticationManager;

    @Autowired
    private JwtUtil jwtUtil;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private PasswordEncoder passwordEncoder;

    // Register a new user
    @PostMapping("/register")
    public ResponseEntity<?> registerUser(@Valid @RequestBody UserRegistrationRequest registrationRequest) {
        User registeredUser = userService.registerUser(registrationRequest);
        Map<String, Object> response = new HashMap<>();
        response.put("message", "User registered successfully!");
        response.put("userId", registeredUser.getId());
        return ResponseEntity.ok(response);
    }

    @GetMapping("/verify")
    public ResponseEntity<?> verifyUser(@RequestParam String token) {
        try {
            userService.verifyUser(token);
            return ResponseEntity.ok(Map.of("message", "Email verified successfully"));
        } catch (RuntimeException e) {
            return ResponseEntity.badRequest().body(Map.of("error", e.getMessage()));
        }
    }

    // Login a user and return a JWT token
    // In UserController.java
    @PostMapping("/login")
    public ResponseEntity<?> login(@Valid @RequestBody LoginRequest loginRequest) {
        try {
            // First check if user exists and is verified
            User user = userRepository.findByEmail(loginRequest.getEmail())
                    .orElseThrow(() -> new UsernameNotFoundException("User not found with email: " + loginRequest.getEmail()));

            if (!user.isEnabled()) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                        .body(Map.of("error", "Account not verified. Please check your email for verification link."));
            }

            // Authenticate the user
            UsernamePasswordAuthenticationToken authToken =
                    new UsernamePasswordAuthenticationToken(loginRequest.getEmail(), loginRequest.getPassword());
            authenticationManager.authenticate(authToken);

            // Load user details and generate a JWT token
            final UserDetails userDetails = userService.loadUserByUsername(loginRequest.getEmail());
            final String jwt = jwtUtil.generateToken(userDetails);

            // Return the response
            Map<String, Object> response = new HashMap<>();
            response.put("message", "Login successful!");
            response.put("userId", user.getId());
            response.put("token", jwt);
            return ResponseEntity.ok(response);

        } catch (BadCredentialsException e) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                    .body(Map.of("error", "Invalid email or password"));
        } catch (UsernameNotFoundException e) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                    .body(Map.of("error", e.getMessage()));
        }
    }


    //get all user
    @GetMapping
    public ResponseEntity<List<User>> getAllUsers() {
        List<User> users = userRepository.findAll();
        return ResponseEntity.ok(users);
    }
    //Get a User by ID
    @GetMapping("/{id}")
    public ResponseEntity<User> getUserById(@PathVariable Long id) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("User not found"));
        return ResponseEntity.ok(user);
    }
    // Update a User (PUT /api/users/{id})
    @PutMapping("/{id}")
    public ResponseEntity<User> updateUser(@PathVariable Long id, @RequestBody User updatedUser) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("User not found"));
        user.setName(updatedUser.getName());
        user.setEmail(updatedUser.getEmail());
        user.setPassword(passwordEncoder.encode(updatedUser.getPassword()));
        userRepository.save(user);
        return ResponseEntity.ok(user);
    }
    // Delete a User (DELETE /api/users/{id})
    @DeleteMapping("/{id}")
    public ResponseEntity<?> deleteUser(@PathVariable Long id) {
        userRepository.deleteById(id);
        return ResponseEntity.ok(Map.of("message", "User deleted successfully"));
    }

    // Add this to UserController.java
    @PostMapping("/logout")
    public ResponseEntity<?> logout(@RequestHeader("Authorization") String authHeader) {
        String token = authHeader.substring(7);
        jwtUtil.invalidateToken(token);
        return ResponseEntity.ok(Map.of("message", "Logged out successfully"));
    }

    // .\controller\UserController.java (add these methods)
    @PostMapping("/forgot-password")
    public ResponseEntity<?> forgotPassword(@Valid @RequestBody ForgotPasswordRequest request) {
        try {
            userService.initiatePasswordReset(request.getEmail());
            return ResponseEntity.ok(Map.of("message", "Password reset link has been sent to your email"));
        } catch (UserNotFoundException e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                    .body(Map.of("error", e.getMessage()));
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of("error", "Failed to send password reset email"));
        }
    }

    @PostMapping("/reset-password")
    public ResponseEntity<?> resetPassword(
            @RequestParam("token") String token,
            @Valid @RequestBody ResetPasswordRequest request) {
        try {
            userService.resetPassword(token, request.getNewPassword());
            return ResponseEntity.ok(Map.of("message", "Password reset successfully"));
        } catch (RuntimeException e) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                    .body(Map.of("error", e.getMessage()));
        }
    }
}

===== .\dto\AdminLoginRequest.java =====

// .\dto\AdminLoginRequest.java
package com.divya.linkedinclone.dto;

import jakarta.validation.constraints.NotBlank;

public class AdminLoginRequest {

    @NotBlank(message = "Username is required")
    private String username;

    @NotBlank(message = "Password is required")
    private String password;

    // Getters and Setters
    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}

===== .\dto\AdminRegistrationRequest.java =====

// .\dto\AdminRegistrationRequest.java
package com.divya.linkedinclone.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public class AdminRegistrationRequest {

    @NotBlank(message = "Username is required")
    private String username;

    @NotBlank(message = "Email is required")
    @Email(message = "Invalid email format")
    private String email;

    @NotBlank(message = "Password is required")
    @Size(min = 8, message = "Password must be at least 8 characters long")
    private String password;

    // Getters and Setters
    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}

===== .\dto\AdminResponse.java =====

// .\dto\AdminResponse.java
package com.divya.linkedinclone.dto;

import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;

@Getter
@Setter
public class AdminResponse {
    private Long id;
    private String username;
    private String email;
    private String role;
    private Boolean isActive;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;

    public AdminResponse(Long id, String username, String email, String role,
                         Boolean isActive, LocalDateTime createdAt, LocalDateTime updatedAt) {
        this.id = id;
        this.username = username;
        this.email = email;
        this.role = role;
        this.isActive = isActive;
        this.createdAt = createdAt;
        this.updatedAt = updatedAt;
    }
}

===== .\dto\CommentResponse.java =====

package com.divya.linkedinclone.dto;

import com.divya.linkedinclone.entity.Comment;
import lombok.Getter;
import lombok.Setter;
import java.time.LocalDateTime;
@Getter
@Setter
public class CommentResponse {
    private Long id;
    private String content;
    private LocalDateTime createdAt;
    private Long postId;
    private Long userId;

    public CommentResponse(Comment comment) {
        this.id = comment.getId();
        this.content = comment.getContent();
        this.createdAt = comment.getCreatedAt();
        this.postId = comment.getPost().getId();
        this.userId = comment.getUser().getId();
    }
}

===== .\dto\ConnectionResponse.java =====

package com.divya.linkedinclone.dto;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class ConnectionResponse {
    private Long senderId;
    private String senderName;
    private String status;

    public ConnectionResponse(Long senderId, String senderName, String status) {
        this.senderId = senderId;
        this.senderName = senderName;
        this.status = status;
    }
}

===== .\dto\CreatePostRequest.java =====

package com.divya.linkedinclone.dto;

public class CreatePostRequest {
    private String content;
    private Long userId;

    // Getters and Setters
    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }

    public Long getUserId() {
        return userId;
    }

    public void setUserId(Long userId) {
        this.userId = userId;
    }
}

===== .\dto\ForgotPasswordRequest.java =====

// .\dto\ForgotPasswordRequest.java
package com.divya.linkedinclone.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;

public class ForgotPasswordRequest {
    @NotBlank(message = "Email is required")
    @Email(message = "Invalid email format")
    private String email;

    // Getters and Setters
    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }
}

===== .\dto\LikeResponse.java =====

package com.divya.linkedinclone.dto;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class LikeResponse {
    private Long postId;
    private Long userId;
    private Long likeCount;

    public LikeResponse(Long postId, Long userId, Long likeCount) {
        this.postId = postId;
        this.userId = userId;
        this.likeCount = likeCount;
    }
}

===== .\dto\LoginRequest.java =====

package com.divya.linkedinclone.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;

public class LoginRequest {

    @NotBlank(message = "Email is required")
    @Email(message = "Invalid email format")
    private String email;

    @NotBlank(message = "Password is required")
    private String password;

    // Getters and Setters
    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}

===== .\dto\MessageResponse.java =====

package com.divya.linkedinclone.dto;

import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;

@Getter
@Setter
public class MessageResponse {
    private Long id;
    private Long senderId;
    private Long receiverId;
    private String message; // Changed from "content" to "message"
    private LocalDateTime sentAt;

    public MessageResponse(Long id, Long senderId, Long receiverId, String message, LocalDateTime sentAt) {
        this.id = id;
        this.senderId = senderId;
        this.receiverId = receiverId;
        this.message = message; // Changed from "content" to "message"
        this.sentAt = sentAt;
    }

    // Getters and Setters
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public Long getSenderId() {
        return senderId;
    }

    public void setSenderId(Long senderId) {
        this.senderId = senderId;
    }

    public Long getReceiverId() {
        return receiverId;
    }

    public void setReceiverId(Long receiverId) {
        this.receiverId = receiverId;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    public LocalDateTime getSentAt() {
        return sentAt;
    }

    public void setSentAt(LocalDateTime sentAt) {
        this.sentAt = sentAt;
    }

}

===== .\dto\NotificationResponse.java =====

package com.divya.linkedinclone.dto;

import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;

@Getter
@Setter
public class NotificationResponse {
    private Long id;
    private Long senderId;
    private String senderName;
    private String message;
    private String status;
    private LocalDateTime createdAt;

    public NotificationResponse(Long id, Long senderId, String senderName, String message, String status, LocalDateTime createdAt) {
        this.id = id;
        this.senderId = senderId;
        this.senderName = senderName;
        this.message = message;
        this.status = status;
        this.createdAt = createdAt;
    }
}

===== .\dto\PostResponse.java =====

package com.divya.linkedinclone.dto;

import com.divya.linkedinclone.entity.Post;
import com.divya.linkedinclone.entity.User;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;

@Getter
@Setter
public class PostResponse {
    private Long id;
    private String content;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    private String imagePath;
    private UserResponse user; // Include user details

    @Getter
    @Setter
    public static class UserResponse {
        private Long id;
        private String name;
        private String email;

        public UserResponse(User user) {
            this.id = user.getId();
            this.name = user.getName();
            this.email = user.getEmail();
        }
    }

    public PostResponse(Post post) {
        this.id = post.getId();
        this.content = post.getContent();
        this.createdAt = post.getCreatedAt();
        this.updatedAt = post.getUpdatedAt();
        this.imagePath = post.getImagePath();
        this.user = new UserResponse(post.getUser()); // Include user details
    }
}

===== .\dto\ResetPasswordRequest.java =====

// .\dto\ResetPasswordRequest.java
package com.divya.linkedinclone.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public class ResetPasswordRequest {
    @NotBlank(message = "Password is required")
    @Size(min = 8, message = "Password must be at least 8 characters long")
    private String newPassword;

    // Getters and Setters
    public String getNewPassword() {
        return newPassword;
    }

    public void setNewPassword(String newPassword) {
        this.newPassword = newPassword;
    }
}

===== .\dto\UserRegistrationRequest.java =====

package com.divya.linkedinclone.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

// In UserRegistrationRequest.java
public class UserRegistrationRequest {

    @NotBlank(message = "Name is required")
    private String name;

    @NotBlank(message = "Email is required")
    @Email(message = "Invalid email format")
    private String email;

    @NotBlank(message = "Password is required")
    @Size(min = 8, message = "Password must be at least 8 characters long")
    private String password;

    // Getters and Setters
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

}

===== .\entity\Admin.java =====

// .\entity\Admin.java
package com.divya.linkedinclone.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;

@Entity
@Getter
@Setter
@Table(name = "admins")
@EntityListeners(AuditingEntityListener.class)
public class Admin {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true)
    private String username;

    @Column(nullable = false, unique = true)
    private String email;

    @Column(nullable = false)
    private String password;

    @Column(nullable = false)
    private String role = "ADMIN";

    @CreatedDate
    private LocalDateTime createdAt;

    @LastModifiedDate
    private LocalDateTime updatedAt;

    @Column(nullable = false)
    private Boolean isActive = true;
}

===== .\entity\Comment.java =====

package com.divya.linkedinclone.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;

@Entity
@Getter
@Setter
@Table(name = "comments")
@EntityListeners(AuditingEntityListener.class)
public class Comment {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String content;

    @CreatedDate
    private LocalDateTime createdAt;

    @ManyToOne
    @JoinColumn(name = "post_id", nullable = false)
    private Post post;

    @ManyToOne
    @JoinColumn(name = "user_id", nullable = false)
    private User user;
}

===== .\entity\Connection.java =====

package com.divya.linkedinclone.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;

@Entity
@Getter
@Setter
@Table(name = "connections")
@EntityListeners(AuditingEntityListener.class)
public class Connection {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "sender_id", nullable = false)
    private User sender;

    @ManyToOne
    @JoinColumn(name = "receiver_id", nullable = false)
    private User receiver;

    @Enumerated(EnumType.STRING)
    private ConnectionStatus status = ConnectionStatus.PENDING;

    @CreatedDate
    private LocalDateTime createdAt;

    public enum ConnectionStatus {
        PENDING, CONNECTED, REJECTED
    }
}

===== .\entity\Follow.java =====

package com.divya.linkedinclone.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;

@Entity
@Getter
@Setter
@Table(name = "follows")
@EntityListeners(AuditingEntityListener.class)
public class Follow {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "follower_id", nullable = false)
    private User follower;

    @ManyToOne
    @JoinColumn(name = "following_id", nullable = false)
    private User following;

    @CreatedDate
    private LocalDateTime createdAt;
}

===== .\entity\Like.java =====

package com.divya.linkedinclone.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

@Entity
@Getter
@Setter
@Table(name = "likes")
public class Like {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "post_id", nullable = false)
    private Post post;

    @ManyToOne
    @JoinColumn(name = "user_id", nullable = false)
    private User user;
}

===== .\entity\Message.java =====

package com.divya.linkedinclone.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;

@Entity
@Getter
@Setter
@Table(name = "messages")
@EntityListeners(AuditingEntityListener.class)
public class Message {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "sender_id", nullable = false)
    private User sender;

    @ManyToOne
    @JoinColumn(name = "receiver_id", nullable = false)
    private User receiver;

    @Column(nullable = false) // Use "message" instead of "content"
    private String message; // Changed from "content" to "message"

    @CreatedDate
    private LocalDateTime sentAt;
}

===== .\entity\Notification.java =====

package com.divya.linkedinclone.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;

@Entity
@Getter
@Setter
@Table(name = "notifications")
@EntityListeners(AuditingEntityListener.class)
public class Notification {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "recipient_id", nullable = false)
    private User recipient;

    @ManyToOne
    @JoinColumn(name = "sender_id", nullable = false)
    private User sender;

    private String message;

    @Enumerated(EnumType.STRING)
    private NotificationStatus status = NotificationStatus.UNREAD;

    @CreatedDate
    private LocalDateTime createdAt;

    public enum NotificationStatus {
        UNREAD, READ
    }
}

===== .\entity\Post.java =====

package com.divya.linkedinclone.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import com.fasterxml.jackson.annotation.JsonIgnore;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;

@Entity
@Getter
@Setter
@Table(name = "posts")
@EntityListeners(AuditingEntityListener.class)
public class Post {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String content;

    @CreatedDate
    private LocalDateTime createdAt;

    @LastModifiedDate
    private LocalDateTime updatedAt;

    private String imagePath;

    @ManyToOne
    @JoinColumn(name = "user_id", nullable = false)
    @JsonIgnore
    private User user;
}

===== .\entity\Profile.java =====

package com.divya.linkedinclone.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import com.fasterxml.jackson.annotation.JsonIgnore;

@Entity
@Getter
@Setter
@Table(name = "profiles")
public class Profile {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String bio;
    private String profilePicture;
    private String skills;
    private String experience;
    private String education;
    private String location;
    private String website;

    // One-to-one relationship with User
    @OneToOne
    @JoinColumn(name = "user_id", referencedColumnName = "id")
    @JsonIgnore
    private User user;
}

===== .\entity\User.java =====

package com.divya.linkedinclone.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Getter;
// Add these imports at the top of User.java
import com.divya.linkedinclone.entity.Profile;
import com.divya.linkedinclone.entity.Post;
import lombok.Setter;
import lombok.ToString;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import com.fasterxml.jackson.annotation.JsonIgnore;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import java.util.HashSet;
import java.util.stream.Collectors;
import org.springframework.security.core.authority.SimpleGrantedAuthority;

@Entity
@Getter
@Setter
@ToString
@Table(name = "users")
public class User implements UserDetails {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotBlank(message = "Name is required")
    private String name;

    @NotBlank(message = "Email is required")
    @Email(message = "Invalid email format")
    private String email;

    @NotBlank(message = "Password is required")
    @Size(min = 8, message = "Password must be at least 8 characters long")
    private String password;

    @Column(nullable = false)
    private boolean enabled = false; // Changed from true to false


    @Override
    public boolean isEnabled() {
        return this.enabled;
    }

    // One-to-one relationship with Profile
    @OneToOne(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    @JsonIgnore
    private Profile profile;

    // One-to-many relationship with Post
    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<Post> posts;

    @Override
    public String getPassword() {
        return this.password;
    }

    @Override
    public String getUsername() {
        return this.email;
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        User user = (User) o;
        return id != null && id.equals(user.id);
    }

    @Override
    public int hashCode() {
        return getClass().hashCode();
    }

    @ElementCollection(fetch = FetchType.EAGER)
    @CollectionTable(name = "user_roles", joinColumns = @JoinColumn(name = "user_id"))
    @Column(name = "role")
    private Set<String> roles = new HashSet<>();

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return roles.stream()
                .map(SimpleGrantedAuthority::new)
                .collect(Collectors.toList());
    }
}

===== .\entity\VerificationToken.java =====

// .\entity\VerificationToken.java
package com.divya.linkedinclone.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;

@Entity
@Getter
@Setter
@Table(name = "verification_tokens")
public class VerificationToken {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String token;

    @OneToOne(targetEntity = User.class, fetch = FetchType.EAGER)
    @JoinColumn(nullable = false, name = "user_id")
    private User user;

    private LocalDateTime expiryDate;

    @Enumerated(EnumType.STRING)
    private TokenType tokenType;

    public enum TokenType {
        VERIFICATION,
        PASSWORD_RESET
    }

    public VerificationToken() {}

    public VerificationToken(String token, User user, TokenType tokenType) {
        this.token = token;
        this.user = user;
        this.tokenType = tokenType;
        this.expiryDate = calculateExpiryDate(24); // 24 hours expiry for verification
    }

    public VerificationToken(String token, User user, TokenType tokenType, int expiryTimeInHours) {
        this.token = token;
        this.user = user;
        this.tokenType = tokenType;
        this.expiryDate = calculateExpiryDate(expiryTimeInHours);
    }

    private LocalDateTime calculateExpiryDate(int expiryTimeInHours) {
        return LocalDateTime.now().plusHours(expiryTimeInHours);
    }

    public boolean isExpired() {
        return LocalDateTime.now().isAfter(expiryDate);
    }

}

===== .\exception\AdminNotFoundException.java =====

// .\exception\AdminNotFoundException.java
package com.divya.linkedinclone.exception;

public class AdminNotFoundException extends RuntimeException {
    public AdminNotFoundException(String message) {
        super(message);
    }
}

===== .\exception\CommentNotFoundException.java =====

package com.divya.linkedinclone.exception;

public class CommentNotFoundException extends RuntimeException {
    public CommentNotFoundException(String message) {
        super(message);
    }
}

===== .\exception\PostNotFoundException.java =====

package com.divya.linkedinclone.exception;

public class PostNotFoundException extends RuntimeException {
  public PostNotFoundException(String message) {
    super(message);
  }
}

===== .\exception\ProfileNotFoundException.java =====

package com.divya.linkedinclone.exception;

public class ProfileNotFoundException extends RuntimeException {
    public ProfileNotFoundException(String message) {
        super(message);
    }
}

===== .\exception\UserNotFoundException.java =====

package com.divya.linkedinclone.exception;

public class UserNotFoundException extends RuntimeException {
    public UserNotFoundException(String message) {
        super(message);
    }
}

===== .\filter\JwtRequestFilter.java =====

package com.divya.linkedinclone.filter;

import com.divya.linkedinclone.service.CustomUserDetailsService;
import com.divya.linkedinclone.util.JwtUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;

@Component
public class JwtRequestFilter extends OncePerRequestFilter {

    @Autowired
    private JwtUtil jwtUtil;

    @Autowired
    private CustomUserDetailsService customUserDetailsService;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
            throws ServletException, IOException {
        final String authorizationHeader = request.getHeader("Authorization");

        String username = null;
        String jwt = null;

        if (authorizationHeader != null && authorizationHeader.startsWith("Bearer ")) {
            jwt = authorizationHeader.substring(7);
            try {
                username = jwtUtil.extractUsername(jwt);
            } catch (Exception e) {
                response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
                response.getWriter().write("{\"message\":\"Token is invalid or expired\"}");
                return;
            }
        }

        if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {
            UserDetails userDetails = this.customUserDetailsService.loadUserByUsername(username);
            logger.debug("User roles: " + userDetails.getAuthorities());
            if (jwtUtil.validateToken(jwt, userDetails)) {
                UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken =
                        new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
                usernamePasswordAuthenticationToken
                        .setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                SecurityContextHolder.getContext().setAuthentication(usernamePasswordAuthenticationToken);
            }
        }

        // If no token provided for protected endpoints
        String requestURI = request.getRequestURI();
        if (!requestURI.equals("/api/users/register") &&
                !requestURI.equals("/api/users/login") &&
                !requestURI.equals("/api/users/verify") &&  // Add this line
                !requestURI.equals("/api/users/forgot-pssword") &&
                !requestURI.equals("/api/users/reset-password") &&

                !requestURI.equals("/api/admin/register") &&  // Add this line
                !requestURI.equals("/api/admin/login") &&
                authorizationHeader == null) {
            response.setStatus(HttpServletResponse.SC_FORBIDDEN);
            response.getWriter().write("{\"message\":\"Access denied\"}");
            return;
        }

        chain.doFilter(request, response);
    }
}

===== .\repository\AdminRepository.java =====

// .\repository\AdminRepository.java
package com.divya.linkedinclone.repository;

import com.divya.linkedinclone.entity.Admin;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface AdminRepository extends JpaRepository<Admin, Long> {
    Optional<Admin> findByUsername(String username);
    Optional<Admin> findByEmail(String email);
}

===== .\repository\CommentRepository.java =====

package com.divya.linkedinclone.repository;

import com.divya.linkedinclone.entity.Comment;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface CommentRepository extends JpaRepository<Comment, Long> {
    List<Comment> findByPostId(Long postId);
}

===== .\repository\ConnectionRepository.java =====

package com.divya.linkedinclone.repository;

import com.divya.linkedinclone.entity.Connection;
import com.divya.linkedinclone.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface ConnectionRepository extends JpaRepository<Connection, Long> {
    Optional<Connection> findBySenderAndReceiver(User sender, User receiver);
    List<Connection> findByReceiverAndStatus(User receiver, Connection.ConnectionStatus status);
    List<Connection> findBySenderOrReceiver(User sender, User receiver);
    List<Connection> findBySender(User sender);
    List<Connection> findByReceiver(User receiver);
}

===== .\repository\FollowRepository.java =====

package com.divya.linkedinclone.repository;

import com.divya.linkedinclone.entity.Follow;
import com.divya.linkedinclone.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface FollowRepository extends JpaRepository<Follow, Long> {
    Optional<Follow> findByFollowerAndFollowing(User follower, User following);
    List<Follow> findByFollower(User follower);
    List<Follow> findByFollowing(User following);
}

===== .\repository\LikeRepository.java =====

package com.divya.linkedinclone.repository;

import com.divya.linkedinclone.entity.Like;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface LikeRepository extends JpaRepository<Like, Long> {
    Optional<Like> findByPostIdAndUserId(Long postId, Long userId);
    Long countByPostId(Long postId);
}

===== .\repository\MessageRepository.java =====

package com.divya.linkedinclone.repository;

import com.divya.linkedinclone.entity.Message;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface MessageRepository extends JpaRepository<Message, Long> {
    List<Message> findBySenderIdAndReceiverId(Long senderId, Long receiverId);
    List<Message> findBySenderIdOrReceiverId(Long userId1, Long userId2);
}

===== .\repository\NotificationRepository.java =====

package com.divya.linkedinclone.repository;

import com.divya.linkedinclone.entity.Notification;
import com.divya.linkedinclone.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface NotificationRepository extends JpaRepository<Notification, Long> {
    List<Notification> findByRecipientAndStatus(User recipient, Notification.NotificationStatus status);
    List<Notification> findByRecipient(User recipient);
}

===== .\repository\PostRepository.java =====

package com.divya.linkedinclone.repository;

import com.divya.linkedinclone.entity.Post;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface PostRepository extends JpaRepository<Post, Long> {
    List<Post> findByUserId(Long userId);
}

===== .\repository\ProfileRepository.java =====

package com.divya.linkedinclone.repository;

import com.divya.linkedinclone.entity.Profile;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface ProfileRepository extends JpaRepository<Profile, Long> {
    Optional<Profile> findByUserId(Long userId);
}

===== .\repository\UserRepository.java =====

package com.divya.linkedinclone.repository;

import com.divya.linkedinclone.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByEmail(String email);
}


===== .\repository\VerificationTokenRepository.java =====

// .\repository\VerificationTokenRepository.java
package com.divya.linkedinclone.repository;

import com.divya.linkedinclone.entity.VerificationToken;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface VerificationTokenRepository extends JpaRepository<VerificationToken, Long> {
    Optional<VerificationToken> findByToken(String token);
    Optional<VerificationToken> findByUserId(Long userId);
    Optional<VerificationToken> findByTokenAndTokenType(String token, VerificationToken.TokenType tokenType);
}

===== .\service\AdminDetailsService.java =====

package com.divya.linkedinclone.service;

import com.divya.linkedinclone.dto.AdminRegistrationRequest;
import com.divya.linkedinclone.entity.Admin;
import com.divya.linkedinclone.exception.AdminNotFoundException;
import com.divya.linkedinclone.repository.AdminRepository;
import org.springframework.beans.factory.annotation.Autowired;

import org.springframework.stereotype.Service;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import java.util.Collections;
import org.springframework.security.core.authority.SimpleGrantedAuthority;

@Service
public class AdminDetailsService implements UserDetailsService {

    @Autowired
    private AdminRepository adminRepository;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        Admin admin = adminRepository.findByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException("Admin not found with username: " + username));

        return new org.springframework.security.core.userdetails.User(
                admin.getUsername(),
                admin.getPassword(),
                Collections.singletonList(new SimpleGrantedAuthority("ROLE_ADMIN")));
    }
}

===== .\service\AdminService.java =====

// .\service\AdminService.java
package com.divya.linkedinclone.service;

import com.divya.linkedinclone.dto.AdminRegistrationRequest;
import com.divya.linkedinclone.entity.Admin;
import com.divya.linkedinclone.exception.AdminNotFoundException;
import com.divya.linkedinclone.repository.AdminRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Service
public class AdminService {

    @Autowired
    private AdminRepository adminRepository;

    @Autowired
    private PasswordEncoder passwordEncoder;

    public Admin registerAdmin(AdminRegistrationRequest registrationRequest) {
        // Check if username or email already exists
        if (adminRepository.findByUsername(registrationRequest.getUsername()).isPresent()) {
            throw new RuntimeException("Username already exists");
        }
        if (adminRepository.findByEmail(registrationRequest.getEmail()).isPresent()) {
            throw new RuntimeException("Email already exists");
        }

        Admin admin = new Admin();
        admin.setUsername(registrationRequest.getUsername());
        admin.setEmail(registrationRequest.getEmail());
        admin.setPassword(passwordEncoder.encode(registrationRequest.getPassword()));
        admin.setRole("ADMIN");
        admin.setIsActive(true);

        return adminRepository.save(admin);
    }

    public Admin authenticateAdmin(String username, String password) {
        Admin admin = adminRepository.findByUsername(username)
                .orElseThrow(() -> new AdminNotFoundException("Admin not found with username: " + username));

        if (!passwordEncoder.matches(password, admin.getPassword())) {
            throw new RuntimeException("Incorrect password");
        }

        if (!admin.getIsActive()) {
            throw new RuntimeException("Admin account is inactive");
        }

        return admin;
    }

    public List<Admin> getAllAdmins() {
        return adminRepository.findAll();
    }

    public Admin getAdminById(Long id) {
        return adminRepository.findById(id)
                .orElseThrow(() -> new AdminNotFoundException("Admin not found with id: " + id));
    }

    public void deleteAdmin(Long id) {
        if (!adminRepository.existsById(id)) {
            throw new AdminNotFoundException("Admin not found with id: " + id);
        }
        adminRepository.deleteById(id);
    }
}

===== .\service\CommentService.java =====

package com.divya.linkedinclone.service;

import com.divya.linkedinclone.entity.Comment;
import com.divya.linkedinclone.entity.Post;
import com.divya.linkedinclone.entity.User;
import com.divya.linkedinclone.exception.PostNotFoundException;
import com.divya.linkedinclone.exception.UserNotFoundException;
import com.divya.linkedinclone.repository.CommentRepository;
import com.divya.linkedinclone.repository.PostRepository;
import com.divya.linkedinclone.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import com.divya.linkedinclone.exception.CommentNotFoundException;
import java.util.List;

@Service
public class CommentService {

    @Autowired
    private CommentRepository commentRepository;

    @Autowired
    private PostRepository postRepository;

    @Autowired
    private UserRepository userRepository;

    public Comment addComment(Long postId, Long userId, String content) {
        Post post = postRepository.findById(postId)
                .orElseThrow(() -> new PostNotFoundException("Post not found with id: " + postId));
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException("User not found with id: " + userId));

        Comment comment = new Comment();
        comment.setContent(content);
        comment.setPost(post);
        comment.setUser(user);

        return commentRepository.save(comment);
    }

    public List<Comment> getCommentsByPostId(Long postId) {
        return commentRepository.findByPostId(postId);
    }

    public void deleteComment(Long commentId) {
        if (!commentRepository.existsById(commentId)) {
            throw new CommentNotFoundException("Comment not found with id: " + commentId);
        }
        commentRepository.deleteById(commentId);
    }
}

===== .\service\ConnectionService.java =====

package com.divya.linkedinclone.service;

import com.divya.linkedinclone.entity.Connection;
import com.divya.linkedinclone.entity.User;
import com.divya.linkedinclone.exception.UserNotFoundException;
import com.divya.linkedinclone.repository.ConnectionRepository;
import com.divya.linkedinclone.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import java.util.stream.Collectors;
import java.util.List;
import java.util.Optional;
import com.divya.linkedinclone.dto.ConnectionResponse;

@Service
public class ConnectionService {

    @Autowired
    private ConnectionRepository connectionRepository;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private NotificationService notificationService; // Add this line


    public String sendConnectionRequest(Long senderId, Long receiverId) {
        User sender = userRepository.findById(senderId)
                .orElseThrow(() -> new UserNotFoundException("Sender user not found with id: " + senderId));
        User receiver = userRepository.findById(receiverId)
                .orElseThrow(() -> new UserNotFoundException("Receiver user not found with id: " + receiverId));

        Optional<Connection> existingConnection = connectionRepository.findBySenderAndReceiver(sender, receiver);
        if (existingConnection.isPresent()) {
            return "Connection request already sent.";
        }

        Connection connection = new Connection();
        connection.setSender(sender);
        connection.setReceiver(receiver);
        connection.setStatus(Connection.ConnectionStatus.PENDING);
        connectionRepository.save(connection);

        // Create a notification for the receiver
        notificationService.createNotification(receiverId, senderId, "You have a new connection request from " + sender.getName());

        return "Connection request sent successfully.";
    }

    public String acceptConnectionRequest(Long receiverId, Long senderId) {
        User receiver = userRepository.findById(receiverId)
                .orElseThrow(() -> new UserNotFoundException("Receiver user not found with id: " + receiverId));
        User sender = userRepository.findById(senderId)
                .orElseThrow(() -> new UserNotFoundException("Sender user not found with id: " + senderId));

        Connection connection = connectionRepository.findBySenderAndReceiver(sender, receiver)
                .orElseThrow(() -> new RuntimeException("Connection request not found."));

        connection.setStatus(Connection.ConnectionStatus.CONNECTED);
        connectionRepository.save(connection);

        // Create a notification for the sender
        notificationService.createNotification(senderId, receiverId, receiver.getName() + " accepted your connection request.");

        return "Connection request accepted. You are now connected!";
    }

    public String rejectConnectionRequest(Long receiverId, Long senderId) {
        User receiver = userRepository.findById(receiverId)
                .orElseThrow(() -> new UserNotFoundException("Receiver user not found with id: " + receiverId));
        User sender = userRepository.findById(senderId)
                .orElseThrow(() -> new UserNotFoundException("Sender user not found with id: " + senderId));

        Connection connection = connectionRepository.findBySenderAndReceiver(sender, receiver)
                .orElseThrow(() -> new RuntimeException("Connection request not found."));

        connection.setStatus(Connection.ConnectionStatus.REJECTED);
        connectionRepository.save(connection);

        // Create a notification for the sender
        notificationService.createNotification(senderId, receiverId, receiver.getName() + " rejected your connection request.");

        return "Connection request rejected.";
    }

    public String cancelConnectionRequest(Long senderId, Long receiverId) {
        User sender = userRepository.findById(senderId)
                .orElseThrow(() -> new UserNotFoundException("Sender user not found with id: " + senderId));
        User receiver = userRepository.findById(receiverId)
                .orElseThrow(() -> new UserNotFoundException("Receiver user not found with id: " + receiverId));

        Connection connection = connectionRepository.findBySenderAndReceiver(sender, receiver)
                .orElseThrow(() -> new RuntimeException("Connection request not found."));

        connectionRepository.delete(connection);

        return "Connection request canceled.";
    }

    public String removeConnection(Long userId, Long connectionId) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException("User not found with id: " + userId));
        User connectionUser = userRepository.findById(connectionId)
                .orElseThrow(() -> new UserNotFoundException("Connection user not found with id: " + connectionId));

        // Find the connection between the two users
        Optional<Connection> connection = connectionRepository.findBySenderAndReceiver(user, connectionUser);
        if (connection.isEmpty()) {
            connection = connectionRepository.findBySenderAndReceiver(connectionUser, user);
        }

        if (connection.isEmpty()) {
            throw new RuntimeException("Connection not found.");
        }

        connectionRepository.delete(connection.get());
        return "Connection removed successfully.";
    }

    public List<ConnectionResponse> getPendingRequests(Long userId) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException("User not found with id: " + userId));
        List<Connection> pendingConnections = connectionRepository.findByReceiverAndStatus(user, Connection.ConnectionStatus.PENDING);
        return pendingConnections.stream()
                .map(connection -> new ConnectionResponse(
                        connection.getSender().getId(),
                        connection.getSender().getName(),
                        connection.getStatus().toString()
                ))
                .collect(Collectors.toList());
    }

    public List<ConnectionResponse> getMutualConnections(Long userId, Long otherUserId) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException("User not found with id: " + userId));
        User otherUser = userRepository.findById(otherUserId)
                .orElseThrow(() -> new UserNotFoundException("Other user not found with id: " + otherUserId));

        List<Connection> userConnections = connectionRepository.findBySenderOrReceiver(user, user);
        List<Connection> otherUserConnections = connectionRepository.findBySenderOrReceiver(otherUser, otherUser);

        // Find mutual connections
        return userConnections.stream()
                .filter(connection -> otherUserConnections.contains(connection))
                .map(connection -> {
                    User connectedUser = connection.getSender().equals(user) ? connection.getReceiver() : connection.getSender();
                    return new ConnectionResponse(connectedUser.getId(), connectedUser.getName(), connection.getStatus().toString());
                })
                .collect(Collectors.toList());
    }

    public List<ConnectionResponse> getAllConnections(Long userId) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException("User not found with id: " + userId));
        List<Connection> connections = connectionRepository.findBySenderOrReceiver(user, user);
        return connections.stream()
                .map(connection -> {
                    User connectedUser = connection.getSender().equals(user) ? connection.getReceiver() : connection.getSender();
                    return new ConnectionResponse(connectedUser.getId(), connectedUser.getName(), connection.getStatus().toString());
                })
                .collect(Collectors.toList());
    }
}

===== .\service\CustomUserDetailsService.java =====

package com.divya.linkedinclone.service;

import com.divya.linkedinclone.entity.User;
import com.divya.linkedinclone.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import java.util.List;
import java.util.Optional;
import com.divya.linkedinclone.entity.Admin;
import java.util.Collections;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import java.util.stream.Collectors;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import com.divya.linkedinclone.repository.AdminRepository;

import java.util.Collections;

@Service
public class CustomUserDetailsService implements UserDetailsService {

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private AdminRepository adminRepository;  // Add this if you have separate admin auth

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        // First try to find as admin
        Optional<Admin> adminOptional = adminRepository.findByUsername(username);
        if (adminOptional.isPresent()) {
            Admin admin = adminOptional.get();
            return new org.springframework.security.core.userdetails.User(
                    admin.getUsername(),
                    admin.getPassword(),
                    Collections.singletonList(new SimpleGrantedAuthority("ROLE_ADMIN")));
        }

        // If not admin, try as regular user
        User user = userRepository.findByEmail(username)
                .orElseThrow(() -> new UsernameNotFoundException("User not found with username/email: " + username));

        List<GrantedAuthority> authorities = user.getRoles().stream()
                .map(role -> new SimpleGrantedAuthority("ROLE_" + role))
                .collect(Collectors.toList());

        return new org.springframework.security.core.userdetails.User(
                user.getEmail(),
                user.getPassword(),
                authorities);
    }
}

===== .\service\EmailService.java =====

package com.divya.linkedinclone.service;

import com.divya.linkedinclone.entity.User;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.stereotype.Service;

@Service
public class EmailService {
    private final JavaMailSender mailSender;

    public EmailService(JavaMailSender mailSender) {
        this.mailSender = mailSender;
    }

    public void sendVerificationEmail(User user, String token) {
        SimpleMailMessage message = new SimpleMailMessage();
        message.setTo(user.getEmail());
        message.setSubject("Verify Your Account");
        message.setText("Please click the link below to verify your account:\n\n"
                + "http://localhost:8080/api/users/verify?token=" + token
                + "\n\nThis link will expire in 24 hours.");

        try {
            mailSender.send(message);
            System.out.println("Verification email sent to: " + user.getEmail());
        } catch (Exception e) {
            System.err.println("Failed to send verification email: " + e.getMessage());
            e.printStackTrace();
        }
    }

    public void sendPasswordResetEmail(User user, String token) {
        SimpleMailMessage message = new SimpleMailMessage();
        message.setTo(user.getEmail());
        message.setSubject("Password Reset Request");
        message.setText("To reset your password, click the link below:\n\n"
                + "http://localhost:8080/api/users/reset-password?token=" + token
                + "\n\nThis link will expire in 1 hour.\n\n"
                + "If you didn't request this, please ignore this email.");

        try {
            mailSender.send(message);
            System.out.println("Password reset email sent to: " + user.getEmail());
        } catch (Exception e) {
            System.err.println("Failed to send password reset email: " + e.getMessage());
            e.printStackTrace();
            throw new RuntimeException("Failed to send password reset email");
        }
    }
}

===== .\service\FollowService.java =====

package com.divya.linkedinclone.service;

import com.divya.linkedinclone.entity.Follow;
import com.divya.linkedinclone.entity.User;
import com.divya.linkedinclone.exception.UserNotFoundException;
import com.divya.linkedinclone.repository.FollowRepository;
import com.divya.linkedinclone.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
public class FollowService {

    @Autowired
    private FollowRepository followRepository;

    @Autowired
    private UserRepository userRepository;

    public String followUser(Long followerId, Long followingId) {
        User follower = userRepository.findById(followerId)
                .orElseThrow(() -> new UserNotFoundException("Follower user not found with id: " + followerId));
        User following = userRepository.findById(followingId)
                .orElseThrow(() -> new UserNotFoundException("Following user not found with id: " + followingId));

        Optional<Follow> existingFollow = followRepository.findByFollowerAndFollowing(follower, following);
        if (existingFollow.isPresent()) {
            return "You are already following this user";
        }

        Follow follow = new Follow();
        follow.setFollower(follower);
        follow.setFollowing(following);
        followRepository.save(follow);

        return "You are now following user " + followingId;
    }

    public String unfollowUser(Long followerId, Long followingId) {
        User follower = userRepository.findById(followerId)
                .orElseThrow(() -> new UserNotFoundException("Follower user not found with id: " + followerId));
        User following = userRepository.findById(followingId)
                .orElseThrow(() -> new UserNotFoundException("Following user not found with id: " + followingId));

        Optional<Follow> existingFollow = followRepository.findByFollowerAndFollowing(follower, following);
        if (existingFollow.isEmpty()) {
            return "You are not following this user";
        }

        followRepository.delete(existingFollow.get());
        return "You have unfollowed user " + followingId;
    }

    public List<Long> getFollowers(Long userId) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException("User not found with id: " + userId));
        return followRepository.findByFollowing(user).stream()
                .map(follow -> follow.getFollower().getId())
                .collect(Collectors.toList());
    }

    public List<Long> getFollowing(Long userId) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException("User not found with id: " + userId));
        return followRepository.findByFollower(user).stream()
                .map(follow -> follow.getFollowing().getId())
                .collect(Collectors.toList());
    }
}

===== .\service\LikeService.java =====

package com.divya.linkedinclone.service;

import com.divya.linkedinclone.entity.Like;
import com.divya.linkedinclone.entity.Post;
import com.divya.linkedinclone.entity.User;
import com.divya.linkedinclone.exception.PostNotFoundException;
import com.divya.linkedinclone.exception.UserNotFoundException;
import com.divya.linkedinclone.repository.LikeRepository;
import com.divya.linkedinclone.repository.PostRepository;
import com.divya.linkedinclone.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import com.divya.linkedinclone.dto.LikeResponse;
import java.util.Optional;

@Service
public class LikeService {

    @Autowired
    private LikeRepository likeRepository;

    @Autowired
    private PostRepository postRepository;

    @Autowired
    private UserRepository userRepository;

    public LikeResponse toggleLike(Long postId, Long userId) {
        Post post = postRepository.findById(postId)
                .orElseThrow(() -> new PostNotFoundException("Post not found with id: " + postId));
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException("User not found with id: " + userId));

        Optional<Like> existingLike = likeRepository.findByPostIdAndUserId(postId, userId);

        if (existingLike.isPresent()) {
            likeRepository.delete(existingLike.get());
        } else {
            Like like = new Like();
            like.setPost(post);
            like.setUser(user);
            likeRepository.save(like);
        }

        Long likeCount = likeRepository.countByPostId(postId);
        return new LikeResponse(postId, userId, likeCount);
    }

    public Long getLikeCount(Long postId) {
        if (!postRepository.existsById(postId)) {
            throw new PostNotFoundException("Post not found with id: " + postId);
        }
        return likeRepository.countByPostId(postId);
    }
}

===== .\service\MessageService.java =====

package com.divya.linkedinclone.service;

import com.divya.linkedinclone.entity.Message;
import com.divya.linkedinclone.entity.User;
import com.divya.linkedinclone.exception.UserNotFoundException;
import com.divya.linkedinclone.repository.MessageRepository;
import com.divya.linkedinclone.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import com.divya.linkedinclone.dto.MessageResponse;
import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class MessageService {

    @Autowired
    private MessageRepository messageRepository;

    @Autowired
    private UserRepository userRepository;

    public Message sendMessage(Long senderId, Long receiverId, String message) {
        User sender = userRepository.findById(senderId)
                .orElseThrow(() -> new UserNotFoundException("Sender not found with id: " + senderId));
        User receiver = userRepository.findById(receiverId)
                .orElseThrow(() -> new UserNotFoundException("Receiver not found with id: " + receiverId));

        Message newMessage = new Message();
        newMessage.setSender(sender);
        newMessage.setReceiver(receiver);
        newMessage.setMessage(message); // Ensure this is correctly defined
        newMessage.setSentAt(LocalDateTime.now());

        return messageRepository.save(newMessage); // Return the Message entity
    }

    public List<MessageResponse> getConversation(Long userId1, Long userId2) {
        List<Message> messages = messageRepository.findBySenderIdAndReceiverId(userId1, userId2);
        messages.addAll(messageRepository.findBySenderIdAndReceiverId(userId2, userId1));

        return messages.stream()
                .map(message -> new MessageResponse(
                        message.getId(),
                        message.getSender().getId(),
                        message.getReceiver().getId(),
                        message.getMessage(), // Changed from "getContent" to "getMessage"
                        message.getSentAt()
                ))
                .collect(Collectors.toList());
    }

    public List<MessageResponse> getAllConversations(Long userId) {
        List<Message> messages = messageRepository.findBySenderIdOrReceiverId(userId, userId);

        return messages.stream()
                .map(message -> new MessageResponse(
                        message.getId(),
                        message.getSender().getId(),
                        message.getReceiver().getId(),
                        message.getMessage(), // Changed from "getContent" to "getMessage"
                        message.getSentAt()
                ))
                .collect(Collectors.toList());
    }
}

===== .\service\NotificationService.java =====

package com.divya.linkedinclone.service;

import com.divya.linkedinclone.entity.Notification;
import com.divya.linkedinclone.entity.User;
import com.divya.linkedinclone.exception.UserNotFoundException;
import com.divya.linkedinclone.repository.NotificationRepository;
import com.divya.linkedinclone.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import com.divya.linkedinclone.dto.NotificationResponse;
import java.util.stream.Collectors;

import java.util.List;

@Service
public class NotificationService {

    @Autowired
    private NotificationRepository notificationRepository;

    @Autowired
    private UserRepository userRepository;

    // Create a new notification
    public Notification createNotification(Long recipientId, Long senderId, String message) {
        User recipient = userRepository.findById(recipientId)
                .orElseThrow(() -> new UserNotFoundException("Recipient user not found with id: " + recipientId));
        User sender = userRepository.findById(senderId)
                .orElseThrow(() -> new UserNotFoundException("Sender user not found with id: " + senderId));

        Notification notification = new Notification();
        notification.setRecipient(recipient);
        notification.setSender(sender);
        notification.setMessage(message);
        return notificationRepository.save(notification);
    }

    // Get all unread notifications for a user
    public List<NotificationResponse> getUnreadNotifications(Long userId) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException("User not found with id: " + userId));
        List<Notification> unreadNotifications = notificationRepository.findByRecipientAndStatus(user, Notification.NotificationStatus.UNREAD);
        return unreadNotifications.stream()
                .map(notification -> new NotificationResponse(
                        notification.getId(),
                        notification.getSender().getId(),
                        notification.getSender().getName(),
                        notification.getMessage(),
                        notification.getStatus().toString(),
                        notification.getCreatedAt()
                ))
                .collect(Collectors.toList());
    }

    // Get all notifications for a user
    public List<NotificationResponse> getAllNotifications(Long userId) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException("User not found with id: " + userId));
        List<Notification> allNotifications = notificationRepository.findByRecipient(user);
        return allNotifications.stream()
                .map(notification -> new NotificationResponse(
                        notification.getId(),
                        notification.getSender().getId(),
                        notification.getSender().getName(),
                        notification.getMessage(),
                        notification.getStatus().toString(),
                        notification.getCreatedAt()
                ))
                .collect(Collectors.toList());
    }

    // Mark a notification as read
    public void markNotificationAsRead(Long notificationId) {
        Notification notification = notificationRepository.findById(notificationId)
                .orElseThrow(() -> new RuntimeException("Notification not found with id: " + notificationId));
        notification.setStatus(Notification.NotificationStatus.READ);
        notificationRepository.save(notification);
    }
}

===== .\service\PostService.java =====

package com.divya.linkedinclone.service;

import com.divya.linkedinclone.entity.Post;
import com.divya.linkedinclone.entity.User;
import com.divya.linkedinclone.repository.PostRepository;
import com.divya.linkedinclone.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.multipart.MultipartFile;
import java.time.LocalDateTime;
import java.util.List;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.UUID;
import com.divya.linkedinclone.exception.PostNotFoundException;


@Service
public class PostService {

    @Autowired
    private PostRepository postRepository;

    @Autowired
    private UserRepository userRepository;


    @Value("${upload.directory}") // Define the upload directory in application.properties
    private String uploadDirectory;

    public Post createPostWithImage(Long userId, String content, MultipartFile image) throws IOException {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new RuntimeException("User not found"));

        // Save the image file
        String imagePath = saveImage(image);

        // Create and save the post
        Post post = new Post();
        post.setContent(content);
        post.setImagePath(imagePath);
        post.setCreatedAt(LocalDateTime.now());
        post.setUser(user);

        return postRepository.save(post);
    }

    private String saveImage(MultipartFile image) throws IOException {
        if (image.isEmpty()) {
            throw new RuntimeException("Image file is empty");
        }

        // Generate a unique file name
        String fileName = UUID.randomUUID().toString() + "_" + image.getOriginalFilename();

        // Create the upload directory if it doesn't exist
        Path uploadPath = Paths.get(uploadDirectory);
        if (!Files.exists(uploadPath)) {
            Files.createDirectories(uploadPath);
        }

        // Save the file to the upload directory
        Path filePath = uploadPath.resolve(fileName);
        Files.copy(image.getInputStream(), filePath);

        return filePath.toString();
    }


    // Create a new post
    public Post createPost(Long userId, String content) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new RuntimeException("User not found"));

        Post post = new Post();
        post.setContent(content);
        post.setCreatedAt(LocalDateTime.now());
        post.setUser(user);

        return postRepository.save(post);
    }


    // Get all posts by a user
    public List<Post> getPostsByUserId(Long userId) {
        if (!userRepository.existsById(userId)) {
            throw new RuntimeException("User not found");
        }
        return postRepository.findByUserId(userId);
    }

    // Get a specific post by ID
    public Post getPostById(Long postId) {
        return postRepository.findById(postId)
                .orElseThrow(() -> new PostNotFoundException("Post not found with id: " + postId));
    }
    public List<Post> getAllPosts() {
        return postRepository.findAll();
    }
    // Update a post
    public Post updatePost(Long postId, String newContent) {
        Post post = postRepository.findById(postId)
                .orElseThrow(() -> new RuntimeException("Post not found with id: " + postId));

        post.setContent(newContent); // Update the content
        return postRepository.save(post); // Save the updated post
    }
    // Delete a post by ID
    public void deletePost(Long postId) {
        if (!postRepository.existsById(postId)) {
            throw new RuntimeException("Post not found");
        }
        postRepository.deleteById(postId);
    }
}

===== .\service\ProfileService.java =====

package com.divya.linkedinclone.service;


import com.divya.linkedinclone.entity.Profile;
import com.divya.linkedinclone.entity.User;
import com.divya.linkedinclone.exception.UserNotFoundException;
import com.divya.linkedinclone.exception.ProfileNotFoundException;

import com.divya.linkedinclone.repository.ProfileRepository;
import com.divya.linkedinclone.repository.UserRepository;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class ProfileService {

    @Autowired
    private ProfileRepository profileRepository;

    @Autowired
    private UserRepository userRepository;

    // Create or update a profile for a user
    public Profile createOrUpdateProfile(Long userId, @Valid Profile profile) {
        // Check if a profile already exists for the user
        Profile existingProfile = profileRepository.findByUserId(userId).orElse(null);

        if (existingProfile != null) {
            // Update the existing profile
            existingProfile.setBio(profile.getBio());
            existingProfile.setProfilePicture(profile.getProfilePicture());
            existingProfile.setSkills(profile.getSkills());
            existingProfile.setExperience(profile.getExperience());
            existingProfile.setEducation(profile.getEducation());
            existingProfile.setLocation(profile.getLocation());
            existingProfile.setWebsite(profile.getWebsite());
            return profileRepository.save(existingProfile);
        } else {
            // Create a new profile
            User user = userRepository.findById(userId)
                    .orElseThrow(() -> new UserNotFoundException("User not found with id: " + userId));
            profile.setUser(user);
            return profileRepository.save(profile);
        }
    }

    // Get profile by user ID
    public Profile getProfileByUserId(Long userId) {
        return profileRepository.findByUserId(userId)
                .orElseThrow(() -> new RuntimeException("Profile not found for user id: " + userId));
    }

    // Delete profile by ID
    public void deleteProfile(Long id) {
        if (!profileRepository.existsById(id)) {
            throw new ProfileNotFoundException("Profile not found with id: " + id);
        }
        profileRepository.deleteById(id);
    }
}

===== .\service\UserService.java =====

package com.divya.linkedinclone.service;

import com.divya.linkedinclone.dto.UserRegistrationRequest;
import com.divya.linkedinclone.entity.Profile;
import com.divya.linkedinclone.entity.User;
import com.divya.linkedinclone.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;
import com.divya.linkedinclone.exception.UserNotFoundException;
import java.util.Set;
import java.util.List;
import com.divya.linkedinclone.entity.VerificationToken;
import com.divya.linkedinclone.service.VerificationTokenService;
import com.divya.linkedinclone.service.EmailService;
import com.divya.linkedinclone.service.ProfileService;

import java.util.Collections;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import java.util.stream.Collectors;
@Service
public class UserService implements UserDetailsService {

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private PasswordEncoder passwordEncoder;

    @Autowired
    private VerificationTokenService verificationTokenService;

    @Autowired
    private EmailService emailService; // We'll create this next

    @Autowired
    private ProfileService profileService; // Inject ProfileService

    // Register a new user
    public User registerUser(UserRegistrationRequest registrationRequest) {
        if (userRepository.findByEmail(registrationRequest.getEmail()).isPresent()) {
            throw new UserNotFoundException("Email already exists");
        }

        User user = new User();
        user.setName(registrationRequest.getName());
        user.setEmail(registrationRequest.getEmail());
        user.setPassword(passwordEncoder.encode(registrationRequest.getPassword()));
        user.setRoles(Set.of("USER"));
        user.setEnabled(false); // User is not enabled until email is verified

        User savedUser = userRepository.save(user);

        // Create verification token
        VerificationToken verificationToken = verificationTokenService.createVerificationToken(savedUser);

        // Send verification email
        emailService.sendVerificationEmail(savedUser, verificationToken.getToken());

        // Create profile (existing code)
        Profile profile = new Profile();
        profile.setBio("");
        profile.setProfilePicture("");
        profile.setSkills("");
        profile.setExperience("");
        profile.setEducation("");
        profile.setLocation("");
        profile.setWebsite("");
        profile.setUser(savedUser);
        profileService.createOrUpdateProfile(savedUser.getId(), profile);

        return savedUser;
    }

    public void verifyUser(String token) {
        VerificationToken verificationToken = verificationTokenService.getVerificationToken(token);
        if (verificationToken == null) {
            throw new RuntimeException("Invalid verification token");
        }

        if (verificationToken.isExpired()) {
            verificationTokenService.deleteToken(verificationToken);
            throw new RuntimeException("Token has expired");
        }

        User user = verificationToken.getUser();
        if (user.isEnabled()) {
            throw new RuntimeException("Account already verified");
        }

        user.setEnabled(true);
        userRepository.save(user);
        verificationTokenService.deleteToken(verificationToken);
    }

    // Find a user by email
    public Optional<User> findByEmail(String email) {
        return userRepository.findByEmail(email);
    }

    // Load user details by email (required for authentication)
    @Override
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
        User user = userRepository.findByEmail(email)
                .orElseThrow(() -> new UsernameNotFoundException("User not found with email: " + email));

        // Ensure the password is BCrypt-encoded
        if (!user.getPassword().startsWith("$2a$")) {
            throw new UsernameNotFoundException("User password is not encoded with BCrypt");
        }

        // Return UserDetails object with the encoded password and authorities
        return new org.springframework.security.core.userdetails.User(
                user.getEmail(),
                user.getPassword(),
                Collections.emptyList() // Add roles/authorities if applicable
        );
    }

    // Add these methods to UserService.java
    public List<Map<String, Object>> getAllUsersForAdmin() {
        List<User> users = userRepository.findAll();
        return users.stream()
                .map(user -> {
                    Map<String, Object> userMap = new HashMap<>();
                    userMap.put("userId", user.getId());
                    userMap.put("name", user.getName());
                    userMap.put("email", user.getEmail());
                    userMap.put("role", user.getRoles().stream().findFirst().orElse("USER"));
                    return userMap;
                })
                .collect(Collectors.toList());
    }

    public Map<String, Object> getUserByIdForAdmin(Long userId) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new RuntimeException("User not found with id: " + userId));

        Map<String, Object> userMap = new HashMap<>();
        userMap.put("userId", user.getId());
        userMap.put("name", user.getName());
        userMap.put("email", user.getEmail());
        userMap.put("role", user.getRoles().stream().findFirst().orElse("USER"));
        return userMap;
    }


    public void deleteUserByAdmin(Long userId) {
        if (!userRepository.existsById(userId)) {
            throw new UserNotFoundException("User not found with id: " + userId);
        }
        userRepository.deleteById(userId);
    }

    // .\service\UserService.java (add these methods)
    public void initiatePasswordReset(String email) {
        User user = userRepository.findByEmail(email)
                .orElseThrow(() -> new UserNotFoundException("User not found with email: " + email));

        // Create and save password reset token
        VerificationToken passwordResetToken = verificationTokenService.createPasswordResetToken(user);

        // Send email with reset link
        emailService.sendPasswordResetEmail(user, passwordResetToken.getToken());
    }

    public void resetPassword(String token, String newPassword) {
        VerificationToken passwordResetToken = verificationTokenService.getPasswordResetToken(token);
        if (passwordResetToken == null) {
            throw new RuntimeException("Invalid password reset token");
        }

        if (passwordResetToken.isExpired()) {
            verificationTokenService.deleteToken(passwordResetToken);
            throw new RuntimeException("Password reset token has expired");
        }

        User user = passwordResetToken.getUser();
        user.setPassword(passwordEncoder.encode(newPassword));
        userRepository.save(user);

        // Delete the token after use
        verificationTokenService.deleteToken(passwordResetToken);
    }
}

===== .\service\VerificationTokenService.java =====

// .\service\VerificationTokenService.java
package com.divya.linkedinclone.service;

import com.divya.linkedinclone.entity.User;
import com.divya.linkedinclone.entity.VerificationToken;
import com.divya.linkedinclone.repository.VerificationTokenRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.UUID;

@Service
public class VerificationTokenService {
    @Autowired
    private VerificationTokenRepository tokenRepository;

    public VerificationToken createVerificationToken(User user) {
        String token = UUID.randomUUID().toString();
        VerificationToken verificationToken = new VerificationToken(token, user, VerificationToken.TokenType.VERIFICATION);
        return tokenRepository.save(verificationToken);
    }

    public VerificationToken createPasswordResetToken(User user) {
        // Password reset tokens expire in 1 hour
        String token = UUID.randomUUID().toString();
        VerificationToken passwordResetToken = new VerificationToken(token, user,
                VerificationToken.TokenType.PASSWORD_RESET, 1);
        return tokenRepository.save(passwordResetToken);
    }

    public VerificationToken getVerificationToken(String token) {
        return tokenRepository.findByToken(token).orElse(null);
    }

    public VerificationToken getPasswordResetToken(String token) {
        return tokenRepository.findByTokenAndTokenType(token, VerificationToken.TokenType.PASSWORD_RESET)
                .orElse(null);
    }

    public void deleteToken(VerificationToken token) {
        tokenRepository.delete(token);
    }
}

===== .\util\JwtUtil.java =====

package com.divya.linkedinclone.util;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.security.Keys;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

import java.util.Base64;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import java.util.function.Function;

@Component
public class JwtUtil {
    private static final String SECRET_KEY = Base64.getEncoder().encodeToString("super_secure_key_12345".getBytes());
    private static final long EXPIRATION_TIME = TimeUnit.MINUTES.toMillis(30); // 30 minutes
    private static final Map<String, Date> invalidatedTokens = new HashMap<>();

    public String extractUsername(String token) {
        return extractClaim(token, Claims::getSubject);
    }

    public Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }

    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }

    private Claims extractAllClaims(String token) {
        return Jwts.parserBuilder()
                .setSigningKey(SECRET_KEY.getBytes())
                .build()
                .parseClaimsJws(token)
                .getBody();
    }

    private Boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date()) || invalidatedTokens.containsKey(token);
    }

    public String generateToken(UserDetails userDetails) {
        Map<String, Object> claims = new HashMap<>();
        return Jwts.builder()
                .setClaims(claims) // Use the provided claims
                .setSubject(userDetails.getUsername())
                .setIssuedAt(new Date(System.currentTimeMillis()))
                .setExpiration(new Date(System.currentTimeMillis() + EXPIRATION_TIME))
                .signWith(Keys.hmacShaKeyFor(SECRET_KEY.getBytes()), SignatureAlgorithm.HS256)
                .compact();
    }

    private String createToken(Map<String, Object> claims, String subject) {
        return Jwts.builder()
                .setClaims(claims)
                .setSubject(subject)
                .setIssuedAt(new Date(System.currentTimeMillis()))
                .setExpiration(new Date(System.currentTimeMillis() + EXPIRATION_TIME))
                .signWith(Keys.hmacShaKeyFor(SECRET_KEY.getBytes()), SignatureAlgorithm.HS256)
                .compact();
    }

    public Boolean validateToken(String token, UserDetails userDetails) {
        final String username = extractUsername(token);
        return (username.equals(userDetails.getUsername()) && !isTokenExpired(token));
    }

    public void invalidateToken(String token) {
        invalidatedTokens.put(token, extractExpiration(token));
    }
}

application.properties:
spring.application.name=linkedin
spring.datasource.url=jdbc:mysql://localhost:3306/linkedin_clone
spring.datasource.username=root
spring.datasource.password=Dsql+27
spring.jpa.hibernate.ddl-auto=update
logging.level.org.springframework.security=DEBUG
upload.directory=uploads
# Enable multipart file uploads
spring.servlet.multipart.enabled=true
# Maximum file size (default is 1MB)
spring.servlet.multipart.max-file-size=10MB
# Maximum request size (default is 10MB)
spring.servlet.multipart.max-request-size=10MB
# Location to store uploaded files temporarily
spring.servlet.multipart.location=/tmp
# Admin settings
admin.default.role=ADMIN
admin.initial.username=admin
admin.initial.email=admin@example.com
admin.initial.password=admin123
# Add to application.properties
# Email Configuration (for production)
spring.mail.host=smtp.gmail.com
spring.mail.port=587
spring.mail.username=divi80564@gmail.com
spring.mail.password=rraefunnjunbsbeu
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true
spring.mail.properties.mail.smtp.starttls.required=true

pom.xml:
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.4.3</version>
        <relativePath/>
    </parent>

    <groupId>com.divya.linkedinclone</groupId>
    <artifactId>linkedin</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>linkedin</name>
    <description>Demo project for Spring Boot</description>

    <properties>
        <java.version>21</java.version>
        <maven.compiler.source>21</maven.compiler.source>
        <maven.compiler.target>21</maven.compiler.target>
    </properties>

    <dependencies>
        <!-- Core Spring Boot Dependencies -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>

        <!-- Lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.30</version> <!-- Use the latest version -->
            <scope>provided</scope>
        </dependency>

        <!-- MySQL Driver -->
        <dependency>
            <groupId>com.mysql</groupId>
            <artifactId>mysql-connector-j</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
        </dependency>

        <!-- JWT for Authentication -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>0.11.5</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>0.11.5</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>0.11.5</version>
            <scope>runtime</scope>
        </dependency>

        <!-- Add to pom.xml -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-mail</artifactId>
        </dependency>


        <!-- Spring Boot Testing -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>

    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.13.0</version>
                <configuration>
                    <source>${java.version}</source>
                    <target>${java.version}</target>
                    <compilerArgs>
                        <arg>--enable-preview</arg>
                    </compilerArgs>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>