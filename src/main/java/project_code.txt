

===== .\project_code.txt =====



===== .\com\divya\linkedinclone\LinkedinApplication.java =====

package com.divya.linkedinclone;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;
@SpringBootApplication
@EnableJpaAuditing // Enable JPA auditing
public class LinkedinApplication {

	public static void main(String[] args) {
		SpringApplication.run(LinkedinApplication.class, args);
	}

}

===== .\config\GlobalExceptionHandler.java =====

package com.divya.linkedinclone.config;
import com.divya.linkedinclone.exception.CommentNotFoundException;
import com.divya.linkedinclone.exception.ProfileNotFoundException;
import com.divya.linkedinclone.exception.PostNotFoundException;

import com.divya.linkedinclone.exception.UserNotFoundException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

import java.util.HashMap;
import java.util.Map;

@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(ProfileNotFoundException.class)
    public ResponseEntity<?> handleProfileNotFoundException(ProfileNotFoundException ex) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(Map.of("error", ex.getMessage()));
    }

    @ExceptionHandler(UserNotFoundException.class)
    public ResponseEntity<?> handleUserNotFoundException(UserNotFoundException ex) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(Map.of("error", ex.getMessage()));
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<?> handleValidationExceptions(MethodArgumentNotValidException ex) {
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getFieldErrors().forEach(error ->
                errors.put(error.getField(), error.getDefaultMessage()));
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errors);
    }

    @ExceptionHandler(RuntimeException.class)
    public ResponseEntity<?> handleRuntimeException(RuntimeException ex) {
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(Map.of("error", ex.getMessage()));
    }

    @ExceptionHandler(PostNotFoundException.class)
    public ResponseEntity<?> handlePostNotFoundException(PostNotFoundException ex) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(Map.of("error", ex.getMessage()));
    }

    @ExceptionHandler(CommentNotFoundException.class)
    public ResponseEntity<?> handleCommentNotFoundException(CommentNotFoundException ex) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(Map.of("error", ex.getMessage()));
    }
}


===== .\config\SecurityConfig.java =====

package com.divya.linkedinclone.config;

import com.divya.linkedinclone.filter.JwtRequestFilter;
import com.divya.linkedinclone.service.CustomUserDetailsService;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpStatus;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.security.web.authentication.HttpStatusEntryPoint;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    private final JwtRequestFilter jwtRequestFilter;
    private final CustomUserDetailsService userDetailsService;

    public SecurityConfig(JwtRequestFilter jwtRequestFilter, CustomUserDetailsService userDetailsService) {
        this.jwtRequestFilter = jwtRequestFilter;
        this.userDetailsService = userDetailsService;
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http.csrf(csrf -> csrf.disable())
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers(
                                "/",
                                "/swagger-ui/**",
                                "/v3/api-docs/**",
                                "/swagger-resources/**",
                                "/swagger-resources",
                                "/swagger-ui.html",
                                "/webjars/**",
                                "/favicon.ico",
                                "/error",
                                "/swagger-ui/index.html",
                                "/v3/api-docs",
                                "/v3/api-docs/swagger-config"
                        ).permitAll()
                        .requestMatchers("/uploads/**").permitAll()
                        .requestMatchers("/api/users/register", "/api/users/login").permitAll()
                        .requestMatchers("/api/admin/**").hasRole("ADMIN")
                        .requestMatchers("/api/user/**").hasAnyRole("USER", "ADMIN")
                        .requestMatchers("/messages/**").authenticated()
                        .anyRequest().authenticated()
                )
                .sessionManagement(session -> session
                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                )
                .exceptionHandling(exceptions -> exceptions
                        .authenticationEntryPoint(new HttpStatusEntryPoint(HttpStatus.UNAUTHORIZED))
                )
                .addFilterBefore(jwtRequestFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authenticationConfiguration) throws Exception {
        return authenticationConfiguration.getAuthenticationManager();
    }

    @Bean
    public DaoAuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder());
        return authProvider;
    }
}

===== .\config\SwaggerConfig.java =====

package com.divya.linkedinclone.config;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Contact;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.info.License;
import io.swagger.v3.oas.models.servers.Server;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.List;

@Configuration
public class SwaggerConfig {

    @Bean
    public OpenAPI myOpenAPI() {
        Server devServer = new Server();
        devServer.setUrl("http://localhost:8080");
        devServer.setDescription("Server URL in Development environment");

        Contact contact = new Contact();
        contact.setEmail("your-email@example.com");
        contact.setName("Your Name");
        contact.setUrl("https://www.your-website.com");

        License mitLicense = new License().name("MIT License").url("https://choosealicense.com/licenses/mit/");

        Info info = new Info()
                .title("LinkedIn Clone API")
                .version("1.0")
                .contact(contact)
                .description("This API exposes endpoints for LinkedIn Clone application.")
                .license(mitLicense);

        return new OpenAPI().info(info).servers(List.of(devServer));
    }
}

===== .\config\WebConfig.java =====

package com.divya.linkedinclone.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Value("${upload.directory}")
    private String uploadDirectory;

    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/uploads/**")
                .addResourceLocations("file:" + uploadDirectory + "/");
    }
}

===== .\controller\CommentController.java =====

package com.divya.linkedinclone.controller;

import com.divya.linkedinclone.service.CommentService;
import com.divya.linkedinclone.dto.CommentResponse;
import com.divya.linkedinclone.entity.Comment;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import java.util.Map;
import java.util.List;
import java.util.stream.Collectors;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;

@RestController
@RequestMapping("/api/comments")
@Tag(name = "Comment Management", description = "Operations related to post comments including creation, retrieval, and deletion")
public class CommentController {

    @Autowired
    private CommentService commentService;

    @Operation(
            summary = "Add a comment to a post",
            description = "Creates a new comment on the specified post by the given user"
    )
    @ApiResponses(value = {
            @ApiResponse(
                    responseCode = "201",
                    description = "Comment created successfully",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(implementation = CommentResponse.class)
                    )
            ),
            @ApiResponse(
                    responseCode = "404",
                    description = "Post or User not found",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(example = "{\"error\": \"Post not found with id: 123\"}")
                    )
            ),
            @ApiResponse(
                    responseCode = "400",
                    description = "Invalid input",
                    content = @Content
            )
    })
            @PostMapping("/{postId}")
    public ResponseEntity<CommentResponse> addComment(
            @Parameter(description = "ID of the post to comment on", example = "1", required = true)
            @PathVariable Long postId,

            @Parameter(description = "ID of the user creating the comment", example = "1", required = true)
            @RequestParam Long userId,

            @io.swagger.v3.oas.annotations.parameters.RequestBody(
                    description = "Comment content in JSON format",
                    required = true,
                    content = @Content(
                            schema = @Schema(example = "{\"content\": \"This is a great post!\"}")
                    )
            )
            @RequestBody Map<String, String> request
    ) {
        String content = request.get("content");
        Comment comment = commentService.addComment(postId, userId, content);
        CommentResponse response = new CommentResponse(comment);
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    @Operation(
            summary = "Get comments for a post",
            description = "Retrieves all comments associated with the specified post ID"
    )
    @ApiResponses(value = {
            @ApiResponse(
                    responseCode = "200",
                    description = "Comments retrieved successfully",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(type = "array", implementation = CommentResponse.class)
                    )
            ),
            @ApiResponse(
                    responseCode = "404",
                    description = "Post not found",
                    content = @Content
            )
    })
    @GetMapping("/{postId}")
    public ResponseEntity<List<CommentResponse>> getCommentsByPostId(
            @Parameter(description = "ID of the post to retrieve comments for", example = "1", required = true)
            @PathVariable Long postId
    ) {
        List<Comment> comments = commentService.getCommentsByPostId(postId);
        List<CommentResponse> responses = comments.stream()
                .map(CommentResponse::new)
                .collect(Collectors.toList());
        return ResponseEntity.ok(responses);
    }

    @Operation(
            summary = "Delete a comment",
            description = "Deletes a comment by its ID if it exists"
    )
    @ApiResponses(value = {
            @ApiResponse(
                    responseCode = "200",
                    description = "Comment deleted successfully",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(example = "{\"message\": \"Comment deleted successfully\"}")
                    )
            ),
            @ApiResponse(
                    responseCode = "404",
                    description = "Comment not found",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(example = "{\"error\": \"Comment not found with id: 123\"}")
                    )
            )
    })
    @DeleteMapping("/{commentId}")
    public ResponseEntity<?> deleteComment(
            @Parameter(description = "ID of the comment to be deleted", example = "1", required = true)
            @PathVariable Long commentId
    ) {
        try {
            commentService.deleteComment(commentId);
            return ResponseEntity.ok("Comment deleted successfully");
        } catch (RuntimeException e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(Map.of("error", e.getMessage()));
        }
    }
}

===== .\controller\ConnectionController.java =====

package com.divya.linkedinclone.controller;

import com.divya.linkedinclone.entity.User;
import com.divya.linkedinclone.service.ConnectionService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import com.divya.linkedinclone.entity.Connection;
import java.util.List;
import java.util.Map;
import com.divya.linkedinclone.dto.ConnectionResponse;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;

@RestController
@RequestMapping("/api/connections")
@Tag(name = "Connection Management", description = "Operations for managing user connections including requests, acceptances, and mutual connections")
public class ConnectionController {

    @Autowired
    private ConnectionService connectionService;

    @Operation(
            summary = "Send connection request",
            description = "Sends a connection request from one user to another"
    )
    @ApiResponses(value = {
            @ApiResponse(
                    responseCode = "200",
                    description = "Connection request sent successfully",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(example = "{\"message\": \"Connection request sent successfully.\"}")
                    )
            ),
            @ApiResponse(
                    responseCode = "404",
                    description = "Sender or receiver not found",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(example = "{\"error\": \"User not found with id: 123\"}")
                    )
            ),
            @ApiResponse(
                    responseCode = "400",
                    description = "Invalid request or duplicate connection request",
                    content = @Content
            )
    })
    @PostMapping("/request")
    public ResponseEntity<?> sendConnectionRequest(
            @io.swagger.v3.oas.annotations.parameters.RequestBody(
                    description = "Connection request details",
                    required = true,
                    content = @Content(
                            schema = @Schema(example = "{\"senderId\": 1, \"receiverId\": 2}")
                    )
            )
            @RequestBody Map<String, Long> request) {
        Long senderId = request.get("senderId");
        Long receiverId = request.get("receiverId");
        String message = connectionService.sendConnectionRequest(senderId, receiverId);
        return ResponseEntity.ok(Map.of("message", message));
    }

    @Operation(
            summary = "Accept connection request",
            description = "Accepts a pending connection request"
    )
    @ApiResponses(value = {
            @ApiResponse(
                    responseCode = "200",
                    description = "Connection request accepted",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(example = "{\"message\": \"Connection request accepted. You are now connected!\"}")
                    )
            ),
            @ApiResponse(
                    responseCode = "404",
                    description = "Request not found or users not found",
                    content = @Content
            )
    })
    @PostMapping("/accept")
    public ResponseEntity<?> acceptConnectionRequest(
            @io.swagger.v3.oas.annotations.parameters.RequestBody(
                    description = "Connection acceptance details",
                    required = true,
                    content = @Content(
                            schema = @Schema(example = "{\"receiverId\": 2, \"senderId\": 1}")
                    )
            )
            @RequestBody Map<String, Long> request) {
        Long receiverId = request.get("receiverId");
        Long senderId = request.get("senderId");
        String message = connectionService.acceptConnectionRequest(receiverId, senderId);
        return ResponseEntity.ok(Map.of("message", message));
    }

    @Operation(
            summary = "Reject connection request",
            description = "Rejects a pending connection request"
    )
    @ApiResponses(value = {
            @ApiResponse(
                    responseCode = "200",
                    description = "Connection request rejected",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(example = "{\"message\": \"Connection request rejected.\"}")
                    )
            ),
            @ApiResponse(
                    responseCode = "404",
                    description = "Request not found or users not found",
                    content = @Content
            )
    })
    @PostMapping("/reject")
    public ResponseEntity<?> rejectConnectionRequest(
            @io.swagger.v3.oas.annotations.parameters.RequestBody(
                    description = "Connection rejection details",
                    required = true,
                    content = @Content(
                            schema = @Schema(example = "{\"receiverId\": 2, \"senderId\": 1}")
                    )
            )
            @RequestBody Map<String, Long> request) {
        Long receiverId = request.get("receiverId");
        Long senderId = request.get("senderId");
        String message = connectionService.rejectConnectionRequest(receiverId, senderId);
        return ResponseEntity.ok(Map.of("message", message));
    }

    @Operation(
            summary = "Cancel connection request",
            description = "Cancels a sent connection request"
    )
    @ApiResponses(value = {
            @ApiResponse(
                    responseCode = "200",
                    description = "Connection request canceled",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(example = "{\"message\": \"Connection request canceled.\"}")
                    )
            ),
            @ApiResponse(
                    responseCode = "404",
                    description = "Request not found or users not found",
                    content = @Content
            )
    })
    @DeleteMapping("/cancel")
    public ResponseEntity<?> cancelConnectionRequest(
            @io.swagger.v3.oas.annotations.parameters.RequestBody(
                    description = "Connection cancellation details",
                    required = true,
                    content = @Content(
                            schema = @Schema(example = "{\"senderId\": 1, \"receiverId\": 2}")
                    )
            )
            @RequestBody Map<String, Long> request) {
        Long senderId = request.get("senderId");
        Long receiverId = request.get("receiverId");
        String message = connectionService.cancelConnectionRequest(senderId, receiverId);
        return ResponseEntity.ok(Map.of("message", message));
    }

    @Operation(
            summary = "Remove connection",
            description = "Removes an existing connection between two users"
    )
    @ApiResponses(value = {
            @ApiResponse(
                    responseCode = "200",
                    description = "Connection removed successfully",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(example = "{\"message\": \"Connection removed successfully.\"}")
                    )
            ),
            @ApiResponse(
                    responseCode = "404",
                    description = "Connection not found or users not found",
                    content = @Content
            )
    })
    @DeleteMapping("/remove")
    public ResponseEntity<?> removeConnection(
            @io.swagger.v3.oas.annotations.parameters.RequestBody(
                    description = "Connection removal details",
                    required = true,
                    content = @Content(
                            schema = @Schema(example = "{\"userId\": 1, \"connectionId\": 2}")
                    )
            )
            @RequestBody Map<String, Long> request) {
        Long userId = request.get("userId");
        Long connectionId = request.get("connectionId");
        String message = connectionService.removeConnection(userId, connectionId);
        return ResponseEntity.ok(Map.of("message", message));
    }

    @Operation(
            summary = "Get pending connection requests",
            description = "Retrieves all pending connection requests for a user"
    )
    @ApiResponses(value = {
            @ApiResponse(
                    responseCode = "200",
                    description = "Pending requests retrieved successfully",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(example = "{\"pendingRequests\": [{\"senderId\": 1, \"senderName\": \"John Doe\", \"status\": \"PENDING\"}]}")
                    )
            ),
            @ApiResponse(
                    responseCode = "404",
                    description = "User not found",
                    content = @Content
            )
    })
    @GetMapping("/pending")
    public ResponseEntity<?> getPendingRequests(
            @Parameter(description = "ID of the user to retrieve pending requests for", example = "1", required = true)
            @RequestParam Long userId) {
        List<ConnectionResponse> pendingRequests = connectionService.getPendingRequests(userId);
        return ResponseEntity.ok(Map.of("pendingRequests", pendingRequests));
    }

    @Operation(
            summary = "Get all connections",
            description = "Retrieves all connections (accepted) for a user"
    )
    @ApiResponses(value = {
            @ApiResponse(
                    responseCode = "200",
                    description = "Connections retrieved successfully",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(example = "{\"connections\": [{\"senderId\": 1, \"senderName\": \"John Doe\", \"status\": \"CONNECTED\"}]}")
                    )
            ),
            @ApiResponse(
                    responseCode = "404",
                    description = "User not found",
                    content = @Content
            )
    })
    @GetMapping("/all")
    public ResponseEntity<?> getAllConnections(
            @Parameter(description = "ID of the user to retrieve connections for", example = "1", required = true)
            @RequestParam Long userId) {
        List<ConnectionResponse> connections = connectionService.getAllConnections(userId);
        return ResponseEntity.ok(Map.of("connections", connections));
    }

    @Operation(
            summary = "Get mutual connections",
            description = "Retrieves mutual connections between two users"
    )
    @ApiResponses(value = {
            @ApiResponse(
                    responseCode = "200",
                    description = "Mutual connections retrieved successfully",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(example = "{\"mutualConnections\": [{\"senderId\": 3, \"senderName\": \"Jane Smith\", \"status\": \"CONNECTED\"}]}")
                    )
            ),
            @ApiResponse(
                    responseCode = "404",
                    description = "One or both users not found",
                    content = @Content
            )
    })
    @GetMapping("/mutual")
    public ResponseEntity<?> getMutualConnections(
            @Parameter(description = "ID of the first user", example = "1", required = true)
            @RequestParam Long userId,

            @Parameter(description = "ID of the second user", example = "2", required = true)
            @RequestParam Long otherUserId) {
        List<ConnectionResponse> mutualConnections = connectionService.getMutualConnections(userId, otherUserId);
        return ResponseEntity.ok(Map.of("mutualConnections", mutualConnections));
    }
}

===== .\controller\FollowController.java =====

package com.divya.linkedinclone.controller;

import com.divya.linkedinclone.service.FollowService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import java.util.List;
import java.util.Map;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;

@RestController
@RequestMapping("/api/connections")
@Tag(name = "Follow Management", description = "Operations for managing user following relationships")
public class FollowController {

    @Autowired
    private FollowService followService;

    @Operation(
            summary = "Follow a user",
            description = "Creates a follow relationship where the follower follows the specified user"
    )
    @ApiResponses(value = {
            @ApiResponse(
                    responseCode = "200",
                    description = "Successfully followed user",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(example = "{\"message\": \"You are now following user 123\"}")
                    )
            ),
            @ApiResponse(
                    responseCode = "404",
                    description = "User not found",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(example = "{\"error\": \"User not found with id: 123\"}")
                    )
            ),
            @ApiResponse(
                    responseCode = "400",
                    description = "Invalid request or already following",
                    content = @Content
            )
    })
    @PostMapping("/follow/{userId}")
    public ResponseEntity<?> followUser(
            @Parameter(description = "ID of the user to be followed", example = "123", required = true)
            @PathVariable Long userId,

            @Parameter(description = "ID of the follower user", example = "456", required = true)
            @RequestParam Long followerId) {
        String message = followService.followUser(followerId, userId);
        return ResponseEntity.ok(Map.of("message", message));
    }

    @Operation(
            summary = "Unfollow a user",
            description = "Removes a follow relationship between users"
    )
    @ApiResponses(value = {
            @ApiResponse(
                    responseCode = "200",
                    description = "Successfully unfollowed user",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(example = "{\"message\": \"You have unfollowed user 123\"}")
                    )
            ),
            @ApiResponse(
                    responseCode = "404",
                    description = "User not found or not following",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(example = "{\"error\": \"You are not following this user\"}")
                    )
            )
    })
    @DeleteMapping("/unfollow/{userId}")
    public ResponseEntity<?> unfollowUser(
            @Parameter(description = "ID of the user to be unfollowed", example = "123", required = true)
            @PathVariable Long userId,

            @Parameter(description = "ID of the follower user", example = "456", required = true)
            @RequestParam Long followerId) {
        String message = followService.unfollowUser(followerId, userId);
        return ResponseEntity.ok(Map.of("message", message));
    }

    @Operation(
            summary = "Get user followers",
            description = "Retrieves a list of user IDs who follow the specified user"
    )
    @ApiResponses(value = {
            @ApiResponse(
                    responseCode = "200",
                    description = "Followers retrieved successfully",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(example = "{\"followers\": [456, 789, 101112]}")
                    )
            ),
            @ApiResponse(
                    responseCode = "404",
                    description = "User not found",
                    content = @Content
            )
    })
    @GetMapping("/followers/{userId}")
    public ResponseEntity<?> getFollowers(
            @Parameter(description = "ID of the user to get followers for", example = "123", required = true)
            @PathVariable Long userId) {
        List<Long> followers = followService.getFollowers(userId);
        return ResponseEntity.ok(Map.of("followers", followers));
    }

    @Operation(
            summary = "Get user following",
            description = "Retrieves a list of user IDs that the specified user is following"
    )
    @ApiResponses(value = {
            @ApiResponse(
                    responseCode = "200",
                    description = "Following list retrieved successfully",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(example = "{\"following\": [789, 101112, 131415]}")
                    )
            ),
            @ApiResponse(
                    responseCode = "404",
                    description = "User not found",
                    content = @Content
            )
    })
    @GetMapping("/following/{userId}")
    public ResponseEntity<?> getFollowing(
            @Parameter(description = "ID of the user to get following list for", example = "123", required = true)
            @PathVariable Long userId) {
        List<Long> following = followService.getFollowing(userId);
        return ResponseEntity.ok(Map.of("following", following));
    }
}

===== .\controller\LikeController.java =====

package com.divya.linkedinclone.controller;

import com.divya.linkedinclone.entity.Like;
import com.divya.linkedinclone.service.LikeService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import com.divya.linkedinclone.dto.LikeResponse;
import java.util.Map;
import com.divya.linkedinclone.exception.PostNotFoundException;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;

@RestController
@RequestMapping("/api/likes")
@Tag(name = "Like Management", description = "Operations for managing post likes including toggling likes and retrieving like counts")
public class LikeController {

    @Autowired
    private LikeService likeService;

    @Operation(
            summary = "Toggle like on a post",
            description = "Adds or removes a like from a post. If the user hasn't liked the post, adds a like. If already liked, removes the like."
    )
    @ApiResponses(value = {
            @ApiResponse(
                    responseCode = "200",
                    description = "Like toggled successfully",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(implementation = LikeResponse.class)
                    )
            ),
            @ApiResponse(
                    responseCode = "404",
                    description = "Post or user not found",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(example = "{\"error\": \"Post not found with id: 123\"}")
                    )
            )
    })
    @PostMapping("/{postId}")
    public ResponseEntity<LikeResponse> toggleLike(
            @Parameter(description = "ID of the post to like/unlike", example = "1", required = true)
            @PathVariable Long postId,

            @Parameter(description = "ID of the user performing the like action", example = "1", required = true)
            @RequestParam Long userId
    ) {
        LikeResponse response = likeService.toggleLike(postId, userId);
        return ResponseEntity.ok(response);
    }

    @Operation(
            summary = "Get like count for a post",
            description = "Retrieves the total number of likes for a specific post"
    )
    @ApiResponses(value = {
            @ApiResponse(
                    responseCode = "200",
                    description = "Like count retrieved successfully",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(example = "{\"postId\": 1, \"likeCount\": 5}")
                    )
            ),
            @ApiResponse(
                    responseCode = "404",
                    description = "Post not found",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(example = "{\"error\": \"Post not found with id: 123\"}")
                    )
            )
    })
    @GetMapping("/{postId}")
    public ResponseEntity<?> getLikeCount(
            @Parameter(description = "ID of the post to get like count for", example = "1", required = true)
            @PathVariable Long postId
    ) {
        try {
            Long likeCount = likeService.getLikeCount(postId);
            return ResponseEntity.ok(Map.of("postId", postId, "likeCount", likeCount));
        } catch (PostNotFoundException e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(Map.of("error", e.getMessage()));
        }
    }
}

===== .\controller\MessageController.java =====

package com.divya.linkedinclone.controller;

import com.divya.linkedinclone.entity.Message;
import com.divya.linkedinclone.dto.MessageResponse;
import com.divya.linkedinclone.service.MessageService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import java.util.List;
import java.util.Map;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;

@RestController
@RequestMapping("/messages")
@Tag(name = "Message Management", description = "Operations for managing user messages including sending and retrieving conversations")
public class MessageController {

    @Autowired
    private MessageService messageService;

    @Operation(
            summary = "Send a message",
            description = "Sends a message from one user to another and returns the message details"
    )
    @ApiResponses(value = {
            @ApiResponse(
                    responseCode = "200",
                    description = "Message sent successfully",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(example = """
                    {
                        "message": "Message sent successfully",
                        "messageId": 123
                    }
                    """)
                    )
            ),
            @ApiResponse(
                    responseCode = "400",
                    description = "Invalid request format",
                    content = @Content
            ),
            @ApiResponse(
                    responseCode = "404",
                    description = "Sender or receiver not found",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(example = "{\"error\": \"User not found with id: 123\"}")
                    )
            )
    })
    @PostMapping("/send")
    public ResponseEntity<?> sendMessage(
            @io.swagger.v3.oas.annotations.parameters.RequestBody(
                    description = "Message details",
                    required = true,
                    content = @Content(
                            schema = @Schema(example = """
                    {
                        "senderId": 1,
                        "receiverId": 2,
                        "message": "Hello there!"
                    }
                    """)
                    )
            )
            @RequestBody Map<String, Object> request) {
        Long senderId = Long.valueOf(request.get("senderId").toString());
        Long receiverId = Long.valueOf(request.get("receiverId").toString());
        String message = request.get("message").toString();

        Message sentMessage = messageService.sendMessage(senderId, receiverId, message);

        MessageResponse response = new MessageResponse(
                sentMessage.getId(),
                sentMessage.getSender().getId(),
                sentMessage.getReceiver().getId(),
                sentMessage.getMessage(),
                sentMessage.getSentAt()
        );

        return ResponseEntity.ok(Map.of(
                "message", "Message sent successfully",
                "messageId", response.getId()
        ));
    }

    @Operation(
            summary = "Get conversation between two users",
            description = "Retrieves the complete message history between two specified users"
    )
    @ApiResponses(value = {
            @ApiResponse(
                    responseCode = "200",
                    description = "Conversation retrieved successfully",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(type = "array", implementation = MessageResponse.class)
                    )
            ),
            @ApiResponse(
                    responseCode = "404",
                    description = "One or both users not found",
                    content = @Content
            )
    })
    @GetMapping("/conversation/{userId1}/{userId2}")
    public ResponseEntity<List<MessageResponse>> getConversation(
            @Parameter(description = "ID of the first user in conversation", example = "1", required = true)
            @PathVariable Long userId1,

            @Parameter(description = "ID of the second user in conversation", example = "2", required = true)
            @PathVariable Long userId2) {
        List<MessageResponse> messages = messageService.getConversation(userId1, userId2);
        return ResponseEntity.ok(messages);
    }

    @Operation(
            summary = "Get all conversations for a user",
            description = "Retrieves all message threads where the specified user is either sender or receiver"
    )
    @ApiResponses(value = {
            @ApiResponse(
                    responseCode = "200",
                    description = "Conversations retrieved successfully",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(type = "array", implementation = MessageResponse.class)
                    )
            ),
            @ApiResponse(
                    responseCode = "404",
                    description = "User not found",
                    content = @Content
            )
    })
    @GetMapping("/conversations/{userId}")
    public ResponseEntity<List<MessageResponse>> getAllConversations(
            @Parameter(description = "ID of the user to retrieve conversations for", example = "1", required = true)
            @PathVariable Long userId) {
        List<MessageResponse> conversations = messageService.getAllConversations(userId);
        return ResponseEntity.ok(conversations);
    }
}

===== .\controller\NotificationController.java =====

package com.divya.linkedinclone.controller;

import com.divya.linkedinclone.entity.Notification;
import com.divya.linkedinclone.service.NotificationService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import java.util.Map;
import java.util.List;
import com.divya.linkedinclone.dto.NotificationResponse;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;

@RestController
@RequestMapping("/api/notifications")
@Tag(name = "Notification Management", description = "Operations for managing user notifications including retrieval and status updates")
public class NotificationController {

    @Autowired
    private NotificationService notificationService;

    @Operation(
            summary = "Get unread notifications",
            description = "Retrieves all unread notifications for a specific user"
    )
    @ApiResponses(value = {
            @ApiResponse(
                    responseCode = "200",
                    description = "Unread notifications retrieved successfully",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(example = """
                    {
                        "unreadNotifications": [
                            {
                                "id": 1,
                                "senderId": 2,
                                "senderName": "John Doe",
                                "message": "You have a new connection request",
                                "status": "UNREAD",
                                "createdAt": "2023-05-15T10:30:00"
                            }
                        ]
                    }
                    """)
                    )
            ),
            @ApiResponse(
                    responseCode = "404",
                    description = "User not found",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(example = "{\"error\": \"User not found with id: 123\"}")
                    )
            )
    })
    @GetMapping("/unread")
    public ResponseEntity<?> getUnreadNotifications(
            @Parameter(description = "ID of the user to retrieve notifications for", example = "1", required = true)
            @RequestParam Long userId) {
        List<NotificationResponse> unreadNotifications = notificationService.getUnreadNotifications(userId);
        return ResponseEntity.ok(Map.of("unreadNotifications", unreadNotifications));
    }

    @Operation(
            summary = "Get all notifications",
            description = "Retrieves all notifications (both read and unread) for a specific user"
    )
    @ApiResponses(value = {
            @ApiResponse(
                    responseCode = "200",
                    description = "All notifications retrieved successfully",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(example = """
                    {
                        "allNotifications": [
                            {
                                "id": 1,
                                "senderId": 2,
                                "senderName": "John Doe",
                                "message": "You have a new connection request",
                                "status": "READ",
                                "createdAt": "2023-05-15T10:30:00"
                            },
                            {
                                "id": 2,
                                "senderId": 3,
                                "senderName": "Jane Smith",
                                "message": "Liked your post",
                                "status": "UNREAD",
                                "createdAt": "2023-05-16T11:45:00"
                            }
                        ]
                    }
                    """)
                    )
            ),
            @ApiResponse(
                    responseCode = "404",
                    description = "User not found",
                    content = @Content
            )
    })
    @GetMapping("/all")
    public ResponseEntity<?> getAllNotifications(
            @Parameter(description = "ID of the user to retrieve notifications for", example = "1", required = true)
            @RequestParam Long userId) {
        List<NotificationResponse> allNotifications = notificationService.getAllNotifications(userId);
        return ResponseEntity.ok(Map.of("allNotifications", allNotifications));
    }

    @Operation(
            summary = "Mark notification as read",
            description = "Updates the status of a notification to 'READ'"
    )
    @ApiResponses(value = {
            @ApiResponse(
                    responseCode = "200",
                    description = "Notification marked as read successfully",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(example = "{\"message\": \"Notification marked as read.\"}")
                    )
            ),
            @ApiResponse(
                    responseCode = "404",
                    description = "Notification not found",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(example = "{\"error\": \"Notification not found with id: 123\"}")
                    )
            )
    })
    @PostMapping("/mark-as-read/{notificationId}")
    public ResponseEntity<?> markNotificationAsRead(
            @Parameter(description = "ID of the notification to mark as read", example = "1", required = true)
            @PathVariable Long notificationId) {
        notificationService.markNotificationAsRead(notificationId);
        return ResponseEntity.ok(Map.of("message", "Notification marked as read."));
    }
}

===== .\controller\PostController.java =====

package com.divya.linkedinclone.controller;

import com.divya.linkedinclone.dto.CreatePostRequest;
import com.divya.linkedinclone.dto.PostResponse;
import com.divya.linkedinclone.entity.Post;
import com.divya.linkedinclone.service.PostService;
import org.springframework.http.HttpStatus;
import org.springframework.web.multipart.MultipartFile;
import java.util.Map;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;

import java.io.IOException;
import java.util.List;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/posts")
@Tag(name = "Post Management", description = "Operations for creating, retrieving, updating, and deleting posts")
public class PostController {

    @Autowired
    private PostService postService;

    @Operation(
            summary = "Create a new post",
            description = "Creates a new text post with the provided content"
    )
    @ApiResponses(value = {
            @ApiResponse(
                    responseCode = "201",
                    description = "Post created successfully",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(implementation = PostResponse.class)
                    )
            ),
            @ApiResponse(
                    responseCode = "404",
                    description = "User not found",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(example = "{\"error\": \"User not found with id: 123\"}")
                    )
            ),
            @ApiResponse(
                    responseCode = "400",
                    description = "Invalid request body",
                    content = @Content
            )
    })
    @PostMapping
    public ResponseEntity<?> createPost(
            @io.swagger.v3.oas.annotations.parameters.RequestBody(
                    description = "Post creation details",
                    required = true,
                    content = @Content(
                            schema = @Schema(implementation = CreatePostRequest.class)
                    )
            )
            @RequestBody CreatePostRequest createPostRequest
    ) {
        try {
            Post createdPost = postService.createPost(createPostRequest.getUserId(), createPostRequest.getContent());
            return ResponseEntity.status(HttpStatus.CREATED).body(new PostResponse(createdPost));
        } catch (RuntimeException e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(Map.of("error", e.getMessage()));
        }
    }

    @Operation(
            summary = "Create a post with image",
            description = "Creates a new post with both text content and an image file"
    )
    @ApiResponses(value = {
            @ApiResponse(
                    responseCode = "201",
                    description = "Post with image created successfully",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(implementation = PostResponse.class)
                    )
            ),
            @ApiResponse(
                    responseCode = "404",
                    description = "User not found",
                    content = @Content
            ),
            @ApiResponse(
                    responseCode = "500",
                    description = "Image upload failed",
                    content = @Content
            )
    })
    @PostMapping("/image")
    public ResponseEntity<?> createPostWithImage(
            @Parameter(description = "ID of the user creating the post", example = "1", required = true)
            @RequestParam("userId") Long userId,

            @Parameter(description = "Text content of the post", example = "Check out this cool photo!", required = true)
            @RequestParam("content") String content,

            @Parameter(description = "Image file to upload", required = true)
            @RequestParam("image") MultipartFile image) {
        try {
            Post createdPost = postService.createPostWithImage(userId, content, image);
            return ResponseEntity.status(HttpStatus.CREATED).body(new PostResponse(createdPost));
        } catch (RuntimeException e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(Map.of("error", e.getMessage()));
        } catch (IOException e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(Map.of("error", "Failed to upload image"));
        }
    }

    @Operation(
            summary = "Get posts by user",
            description = "Retrieves all posts created by a specific user"
    )
    @ApiResponses(value = {
            @ApiResponse(
                    responseCode = "200",
                    description = "Post retrieved successfully",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(implementation = PostResponse.class)
                    )
            ),
            @ApiResponse(
                    responseCode = "404",
                    description = "Post not found",
                    content = @Content
            )
    })
    @GetMapping("/users/{userId}/posts")
    public ResponseEntity<?> getPostsByUserId(
            @Parameter(description = "ID of the user to retrieve posts for", example = "1", required = true)
            @PathVariable Long userId) {
        try {
            List<Post> posts = postService.getPostsByUserId(userId);
            List<PostResponse> postResponses = posts.stream()
                    .map(PostResponse::new)
                    .collect(Collectors.toList());
            return ResponseEntity.ok(postResponses);
        } catch (RuntimeException e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(Map.of("error", e.getMessage()));
        }
    }

    @Operation(
            summary = "Get post by ID",
            description = "Retrieves a single post by its unique identifier"
    )
    @ApiResponses(value = {
            @ApiResponse(
                    responseCode = "200",
                    description = "Post retrieved successfully",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(implementation = PostResponse.class)
                    )
            ),
            @ApiResponse(
                    responseCode = "404",
                    description = "Post not found",
                    content = @Content
            )
    })
    @GetMapping("/{postId}")
    public ResponseEntity<?> getPostById(
            @Parameter(description = "ID of the post to retrieve", example = "1", required = true)
            @PathVariable Long postId) {
        try {
            Post post = postService.getPostById(postId);
            return ResponseEntity.ok(new PostResponse(post));
        } catch (RuntimeException e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(Map.of("error", e.getMessage()));
        }
    }

    @Operation(
            summary = "Get all posts",
            description = "Retrieves all posts in the system, ordered by creation date (newest first)"
    )
    @ApiResponse(
            responseCode = "200",
            description = "Posts retrieved successfully",
            content = @Content(
                    mediaType = "application/json",
                    schema = @Schema(type = "array", implementation = PostResponse.class)
            )
    )
    @GetMapping
    public ResponseEntity<List<PostResponse>> getAllPosts() {
        List<Post> posts = postService.getAllPosts();
        List<PostResponse> postResponses = posts.stream()
                .map(PostResponse::new)
                .collect(Collectors.toList());
        return ResponseEntity.ok(postResponses);
    }

    @Operation(
            summary = "Update post content",
            description = "Updates the text content of an existing post"
    )
    @ApiResponses(value = {
            @ApiResponse(
                    responseCode = "200",
                    description = "Post updated successfully",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(implementation = PostResponse.class)
                    )
            ),
            @ApiResponse(
                    responseCode = "404",
                    description = "Post not found",
                    content = @Content
            )
    })
    @PutMapping("/{postId}")
    public ResponseEntity<?> updatePost(
            @Parameter(description = "ID of the post to update", example = "1", required = true)
            @PathVariable Long postId,

            @io.swagger.v3.oas.annotations.parameters.RequestBody(
                    description = "New post content",
                    required = true,
                    content = @Content(
                            schema = @Schema(example = "{\"content\": \"Updated post content\"}")
                    )
            )
            @RequestBody Map<String, String> request) {
        try {
            String newContent = request.get("content");
            Post updatedPost = postService.updatePost(postId, newContent);
            return ResponseEntity.ok(new PostResponse(updatedPost));
        } catch (RuntimeException e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(Map.of("error", e.getMessage()));
        }
    }

    @Operation(
            summary = "Delete a post",
            description = "Permanently deletes a post from the system"
    )
    @ApiResponses(value = {
            @ApiResponse(
                    responseCode = "200",
                    description = "Post deleted successfully",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(example = "{\"message\": \"Post deleted successfully!\"}")
                    )
            ),
            @ApiResponse(
                    responseCode = "404",
                    description = "Post not found",
                    content = @Content
            )
    })
    @DeleteMapping("/{postId}")
    public ResponseEntity<?> deletePost(
            @Parameter(description = "ID of the post to delete", example = "1", required = true)
            @PathVariable Long postId) {
        try {
            postService.deletePost(postId);
            return ResponseEntity.ok(Map.of("message", "Post deleted successfully!"));
        } catch (RuntimeException e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(Map.of("error", e.getMessage()));
        }
    }
}

===== .\controller\ProfileController.java =====

package com.divya.linkedinclone.controller;

import java.util.Optional;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.springframework.http.HttpStatus;
import com.divya.linkedinclone.entity.Profile;
import com.divya.linkedinclone.repository.ProfileRepository;
import com.divya.linkedinclone.service.ProfileService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;

@RestController
@RequestMapping("/api/profiles")
@Tag(name = "Profile Management", description = "Operations for managing user profiles including creation, retrieval, and updates")
public class ProfileController {

    @Autowired
    private ProfileService profileService;

    @Autowired
    private ProfileRepository profileRepository;

    @Operation(
            summary = "Create or update profile",
            description = "Creates a new profile or updates an existing one for the specified user"
    )
    @ApiResponses(value = {
            @ApiResponse(
                    responseCode = "200",
                    description = "Profile saved successfully",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(implementation = Profile.class)
                    )
            ),
            @ApiResponse(  // Fixed: properly closed previous @ApiResponse
                    responseCode = "404",
                    description = "User not found",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(example = "{\"error\": \"User not found with id: 123\"}")
                    )
            ),
            @ApiResponse(
                    responseCode = "400",
                    description = "Invalid profile data",
                    content = @Content
            )
    })  // Fixed: properly closed @ApiResponses
            @PostMapping("/{userId}")
    public ResponseEntity<Profile> createOrUpdateProfile(
            @Parameter(description = "ID of the user to create/update profile for", example = "1", required = true)
            @PathVariable Long userId,

            @io.swagger.v3.oas.annotations.parameters.RequestBody(
                    description = "Profile details",
                    required = true,
                    content = @Content(
                            schema = @Schema(implementation = Profile.class)
                    ))
            @RequestBody Profile profile
    ) {
        Profile savedProfile = profileService.createOrUpdateProfile(userId, profile);
        return ResponseEntity.ok(savedProfile);
    }

    @Operation(
            summary = "Get profile by user ID",
            description = "Retrieves complete profile information for a specific user"
    )
    @ApiResponses(value = {
            @ApiResponse(
                    responseCode = "200",
                    description = "Profile retrieved successfully",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(example = """
                    {
                        "id": 1,
                        "user": {
                            "id": 1,
                            "name": "John Doe",
                            "email": "john@example.com"
                        },
                        "bio": "Software Engineer",
                        "profilePicture": "/uploads/profile1.jpg",
                        "skills": "Java, Spring Boot",
                        "experience": "5 years at Tech Corp",
                        "education": "MS in Computer Science",
                        "location": "New York",
                        "website": "https://john.dev"
                    }
                    """)
                    )
            ),
            @ApiResponse(
                    responseCode = "404",
                    description = "Profile not found",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(example = "{\"error\": \"Profile not found for user id: 123\"}")
                    )
            )
    })
    @GetMapping("/{userId}")
    public ResponseEntity<?> getProfileByUserId(
            @Parameter(description = "ID of the user to retrieve profile for", example = "1", required = true)
            @PathVariable Long userId) {
        Profile profile = profileService.getProfileByUserId(userId);
        Map<String, Object> response = new HashMap<>();
        response.put("id", profile.getId());
        response.put("user", Map.of(
                "id", profile.getUser().getId(),
                "name", profile.getUser().getName(),
                "email", profile.getUser().getEmail()
        ));
        response.put("bio", profile.getBio());
        response.put("profilePicture", profile.getProfilePicture());
        response.put("skills", profile.getSkills());
        response.put("experience", profile.getExperience());
        response.put("education", profile.getEducation());
        response.put("location", profile.getLocation());
        response.put("website", profile.getWebsite());
        return ResponseEntity.ok(response);
    }

    @Operation(
            summary = "Get all profiles",
            description = "Retrieves a list of all user profiles in the system"
    )
    @ApiResponse(
            responseCode = "200",
            description = "Profiles retrieved successfully",
            content = @Content(
                    mediaType = "application/json",
                    schema = @Schema(type = "array", implementation = Profile.class)
            )
    )
    @GetMapping
    public ResponseEntity<List<Profile>> getAllProfiles() {
        List<Profile> profiles = profileRepository.findAll();
        return ResponseEntity.ok(profiles);
    }

    @Operation(
            summary = "Update profile by ID",
            description = "Updates specific fields of an existing profile"
    )
    @ApiResponses(value = {
            @ApiResponse(
                    responseCode = "200",
                    description = "Profile updated successfully",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(implementation = Profile.class)
                    )
            ),
            @ApiResponse(
                    responseCode = "404",
                    description = "Profile not found",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(example = "{\"error\": \"Profile not found with id: 123\"}")
                    )
            )
    })
    @PutMapping("/{id}")
    public ResponseEntity<?> updateProfile(
            @Parameter(description = "ID of the profile to update", example = "1", required = true)
            @PathVariable Long id,

            @io.swagger.v3.oas.annotations.parameters.RequestBody(
                    description = "Updated profile fields",
                    required = true,
                    content = @Content(
                            schema = @Schema(implementation = Profile.class)
                    ))
            @RequestBody Profile updatedProfile
    ) {
        Optional<Profile> optionalProfile = profileRepository.findById(id);

        if (optionalProfile.isPresent()) {
            Profile profile = optionalProfile.get();
            profile.setBio(updatedProfile.getBio());
            profile.setProfilePicture(updatedProfile.getProfilePicture());
            profile.setSkills(updatedProfile.getSkills());
            profile.setExperience(updatedProfile.getExperience());
            profile.setEducation(updatedProfile.getEducation());
            profile.setLocation(updatedProfile.getLocation());
            profile.setWebsite(updatedProfile.getWebsite());

            Profile savedProfile = profileRepository.save(profile);
            return ResponseEntity.ok(savedProfile);
        } else {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(Map.of("error", "Profile not found with id: " + id));
        }
    }

    @Operation(
            summary = "Delete profile by ID",
            description = "Permanently deletes a user profile"
    )
    @ApiResponses(value = {
            @ApiResponse(
                    responseCode = "200",
                    description = "Profile deleted successfully",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(example = "{\"message\": \"Profile deleted successfully\"}")
                    )
            ),
            @ApiResponse(
                    responseCode = "404",
                    description = "Profile not found",
                    content = @Content
            )
    })
    @DeleteMapping("/{id}")
    public ResponseEntity<?> deleteProfile(
            @Parameter(description = "ID of the profile to delete", example = "1", required = true)
            @PathVariable Long id) {
        profileService.deleteProfile(id);
        return ResponseEntity.ok(Map.of("message", "Profile deleted successfully"));
    }
}

===== .\controller\UserController.java =====

package com.divya.linkedinclone.controller;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import java.util.HashMap;
import java.util.Map;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import com.divya.linkedinclone.dto.LoginRequest;
import com.divya.linkedinclone.dto.UserRegistrationRequest;
import com.divya.linkedinclone.repository.UserRepository;
import java.util.List;
import com.divya.linkedinclone.entity.User;
import com.divya.linkedinclone.service.UserService;
import com.divya.linkedinclone.util.JwtUtil;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.*;
import org.springframework.security.crypto.password.PasswordEncoder;

@RestController
@RequestMapping("/api/users")
@Tag(name = "User Management", description = "Operations related to user management including registration, authentication, and CRUD operations")
public class UserController {

    @Autowired
    private UserService userService;

    @Autowired
    private AuthenticationManager authenticationManager;

    @Autowired
    private JwtUtil jwtUtil;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private PasswordEncoder passwordEncoder;

    @Operation(
            summary = "Register a new user",
            description = "Creates a new user account with the provided details. Returns the user ID upon successful registration."
    )
    @ApiResponses(value = {
            @ApiResponse(
                    responseCode = "200",
                    description = "User registered successfully",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(implementation = Map.class, example = "{\"message\": \"User registered successfully!\", \"userId\": 1}")
                    )
            ),
            @ApiResponse(
                    responseCode = "400",
                    description = "Invalid input data",
                    content = @Content
            ),
            @ApiResponse(
                    responseCode = "409",
                    description = "Email already exists",
                    content = @Content
            )
    })
    @PostMapping("/register")
    public ResponseEntity<?> registerUser(@Valid @RequestBody UserRegistrationRequest registrationRequest) {
        User registeredUser = userService.registerUser(registrationRequest);
        Map<String, Object> response = new HashMap<>();
        response.put("message", "User registered successfully!");
        response.put("userId", registeredUser.getId());
        return ResponseEntity.ok(response);
    }

    @Operation(
            summary = "Authenticate user",
            description = "Authenticates a user with email and password, returns a JWT token upon successful authentication."
    )
    @ApiResponses(value = {
            @ApiResponse(
                    responseCode = "200",
                    description = "Login successful",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(implementation = Map.class, example = "{\"message\": \"Login successful!\", \"userId\": 1, \"token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\"}")
                    )
            ),
            @ApiResponse(
                    responseCode = "401",
                    description = "Invalid credentials",
                    content = @Content
            )
    })
    @PostMapping("/login")
    public ResponseEntity<?> login(@Valid @RequestBody LoginRequest loginRequest) {
        try {
            UsernamePasswordAuthenticationToken authToken =
                    new UsernamePasswordAuthenticationToken(loginRequest.getEmail(), loginRequest.getPassword());
            authenticationManager.authenticate(authToken);
        } catch (BadCredentialsException e) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("Invalid email or password");
        }

        final UserDetails userDetails = userService.loadUserByUsername(loginRequest.getEmail());
        final String jwt = jwtUtil.generateToken(userDetails);

        User user = userRepository.findByEmail(loginRequest.getEmail())
                .orElseThrow(() -> new UsernameNotFoundException("User not found with email: " + loginRequest.getEmail()));

        Map<String, Object> response = new HashMap<>();
        response.put("message", "Login successful!");
        response.put("userId", user.getId());
        response.put("token", jwt);
        return ResponseEntity.ok(response);
    }

    @Operation(
            summary = "Get all users",
            description = "Retrieves a list of all registered users in the system."
    )
    @ApiResponse(
            responseCode = "200",
            description = "List of users retrieved successfully",
            content = @Content(
                    mediaType = "application/json",
                    schema = @Schema(implementation = User.class, type = "array")
            )
    )
    @GetMapping
    public ResponseEntity<List<User>> getAllUsers() {
        List<User> users = userRepository.findAll();
        return ResponseEntity.ok(users);
    }

    @Operation(
            summary = "Get user by ID",
            description = "Retrieves a single user by their unique identifier."
    )
    @ApiResponses(value = {
            @ApiResponse(
                    responseCode = "200",
                    description = "User found",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(implementation = User.class)
                    )
            ),
            @ApiResponse(
                    responseCode = "404",
                    description = "User not found",
                    content = @Content
            )
    })
    @GetMapping("/{id}")
    public ResponseEntity<User> getUserById(
            @Parameter(description = "ID of the user to be retrieved", example = "1", required = true)
            @PathVariable Long id) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("User not found"));
        return ResponseEntity.ok(user);
    }

    @Operation(
            summary = "Update user",
            description = "Updates the details of an existing user. All fields will be updated with the provided values."
    )
    @ApiResponses(value = {
            @ApiResponse(
                    responseCode = "200",
                    description = "User updated successfully",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(implementation = User.class)
                    )
            ),
            @ApiResponse(
                    responseCode = "404",
                    description = "User not found",
                    content = @Content
            ),
            @ApiResponse(
                    responseCode = "400",
                    description = "Invalid input data",
                    content = @Content
            )
    })
    @PutMapping("/{id}")
    public ResponseEntity<User> updateUser(
            @Parameter(description = "ID of the user to be updated", example = "1", required = true)
            @PathVariable Long id,

            @io.swagger.v3.oas.annotations.parameters.RequestBody(
                    description = "Updated user object",
                    required = true,
                    content = @Content(
                            schema = @Schema(implementation = User.class)
                    )
            )
            @RequestBody User updatedUser) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("User not found"));
        user.setName(updatedUser.getName());
        user.setEmail(updatedUser.getEmail());
        user.setPassword(passwordEncoder.encode(updatedUser.getPassword()));
        userRepository.save(user);
        return ResponseEntity.ok(user);
    }

    @Operation(
            summary = "Delete user",
            description = "Deletes a user from the system by their ID."
    )
    @ApiResponses(value = {
            @ApiResponse(
                    responseCode = "200",
                    description = "User deleted successfully",
                    content = @Content(
                            mediaType = "application/json",
                            schema = @Schema(implementation = Map.class, example = "{\"message\": \"User deleted successfully\"}")
                    )
            ),
            @ApiResponse(
                    responseCode = "404",
                    description = "User not found",
                    content = @Content
            )
    })
    @DeleteMapping("/{id}")
    public ResponseEntity<?> deleteUser(
            @Parameter(description = "ID of the user to be deleted", example = "1", required = true)
            @PathVariable Long id) {
        userRepository.deleteById(id);
        return ResponseEntity.ok(Map.of("message", "User deleted successfully"));
    }
}

===== .\dto\CommentResponse.java =====

package com.divya.linkedinclone.dto;

import com.divya.linkedinclone.entity.Comment;
import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Getter;
import lombok.Setter;
import java.time.LocalDateTime;

@Getter
@Setter
@Schema(description = "Response object representing a comment on a post")
public class CommentResponse {

    @Schema(
            description = "Unique identifier of the comment",
            example = "1",
            accessMode = Schema.AccessMode.READ_ONLY
    )
    private Long id;

    @Schema(
            description = "Text content of the comment",
            example = "This is an insightful post!",
            required = true,
            maxLength = 1000
    )
    private String content;

    @Schema(
            description = "Timestamp when the comment was created",
            example = "2023-05-15T14:30:00",
            accessMode = Schema.AccessMode.READ_ONLY
    )
    private LocalDateTime createdAt;

    @Schema(
            description = "ID of the post this comment belongs to",
            example = "5",
            accessMode = Schema.AccessMode.READ_ONLY
    )
    private Long postId;

    @Schema(
            description = "ID of the user who created the comment",
            example = "10",
            accessMode = Schema.AccessMode.READ_ONLY
    )
    private Long userId;

    public CommentResponse(Comment comment) {
        this.id = comment.getId();
        this.content = comment.getContent();
        this.createdAt = comment.getCreatedAt();
        this.postId = comment.getPost().getId();
        this.userId = comment.getUser().getId();
    }
}

===== .\dto\ConnectionResponse.java =====

package com.divya.linkedinclone.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@Schema(description = "Response object representing a connection between users")
public class ConnectionResponse {

    @Schema(
            description = "Unique identifier of the user who initiated the connection",
            example = "123",
            required = true,
            accessMode = Schema.AccessMode.READ_ONLY
    )
    private Long senderId;

    @Schema(
            description = "Name of the user who initiated the connection",
            example = "John Doe",
            required = true,
            accessMode = Schema.AccessMode.READ_ONLY
    )
    private String senderName;

    @Schema(
            description = "Current status of the connection",
            example = "PENDING",
            required = true,
            allowableValues = {"PENDING", "CONNECTED", "REJECTED"},
            accessMode = Schema.AccessMode.READ_ONLY
    )
    private String status;

    public ConnectionResponse(Long senderId, String senderName, String status) {
        this.senderId = senderId;
        this.senderName = senderName;
        this.status = status;
    }
}

===== .\dto\CreatePostRequest.java =====

package com.divya.linkedinclone.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;

@Schema(description = "Request object for creating a new post")
public class CreatePostRequest {

    @Schema(
            description = "Content/text of the post",
            example = "Check out this amazing new feature we just launched!",
            required = true,
            minLength = 1,
            maxLength = 1000
    )
    @NotBlank(message = "Content cannot be blank")
    private String content;

    @Schema(
            description = "ID of the user creating the post",
            example = "123",
            required = true
    )
    @NotNull(message = "User ID cannot be null")
    private Long userId;

    // Getters and Setters
    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }

    public Long getUserId() {
        return userId;
    }

    public void setUserId(Long userId) {
        this.userId = userId;
    }
}

===== .\dto\LikeResponse.java =====

package com.divya.linkedinclone.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@Schema(description = "Response object representing a like action on a post")
public class LikeResponse {

    @Schema(
            description = "ID of the post that was liked/unliked",
            example = "456",
            required = true,
            accessMode = Schema.AccessMode.READ_ONLY
    )
    private Long postId;

    @Schema(
            description = "ID of the user who performed the like action",
            example = "123",
            required = true,
            accessMode = Schema.AccessMode.READ_ONLY
    )
    private Long userId;

    @Schema(
            description = "Total number of likes on the post after this action",
            example = "42",
            required = true,
            minimum = "0",
            accessMode = Schema.AccessMode.READ_ONLY
    )
    private Long likeCount;

    public LikeResponse(Long postId, Long userId, Long likeCount) {
        this.postId = postId;
        this.userId = userId;
        this.likeCount = likeCount;
    }
}

===== .\dto\LoginRequest.java =====

package com.divya.linkedinclone.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;

@Schema(description = "Request object for user authentication")
public class LoginRequest {

    @Schema(
            description = "User's registered email address",
            example = "user@example.com",
            required = true,
            format = "email",
            maxLength = 100
    )
    @NotBlank(message = "Email is required")
    @Email(message = "Invalid email format")
    private String email;

    @Schema(
            description = "User's password",
            example = "securePassword123!",
            required = true,
            minLength = 8,
            maxLength = 50,
            format = "password"
    )
    @NotBlank(message = "Password is required")
    private String password;

    // Getters and Setters
    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}

===== .\dto\MessageResponse.java =====

package com.divya.linkedinclone.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;

@Getter
@Setter
@Schema(description = "Response object representing a message between users")
public class MessageResponse {

    @Schema(
            description = "Unique identifier of the message",
            example = "1",
            accessMode = Schema.AccessMode.READ_ONLY
    )
    private Long id;

    @Schema(
            description = "ID of the user who sent the message",
            example = "101",
            accessMode = Schema.AccessMode.READ_ONLY
    )
    private Long senderId;

    @Schema(
            description = "ID of the user who received the message",
            example = "102",
            accessMode = Schema.AccessMode.READ_ONLY
    )
    private Long receiverId;

    @Schema(
            description = "Content of the message",
            example = "Hello! How are you doing?",
            maxLength = 2000,
            accessMode = Schema.AccessMode.READ_ONLY
    )
    private String message;

    @Schema(
            description = "Timestamp when the message was sent",
            example = "2023-05-15T14:30:45",
            accessMode = Schema.AccessMode.READ_ONLY
    )
    private LocalDateTime sentAt;

    public MessageResponse(Long id, Long senderId, Long receiverId, String message, LocalDateTime sentAt) {
        this.id = id;
        this.senderId = senderId;
        this.receiverId = receiverId;
        this.message = message;
        this.sentAt = sentAt;
    }
}

===== .\dto\NotificationResponse.java =====

package com.divya.linkedinclone.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;

@Getter
@Setter
@Schema(description = "Response object representing a user notification")
public class NotificationResponse {

    @Schema(
            description = "Unique identifier of the notification",
            example = "1",
            accessMode = Schema.AccessMode.READ_ONLY
    )
    private Long id;

    @Schema(
            description = "ID of the user who triggered the notification",
            example = "101",
            accessMode = Schema.AccessMode.READ_ONLY
    )
    private Long senderId;

    @Schema(
            description = "Name of the user who triggered the notification",
            example = "John Doe",
            accessMode = Schema.AccessMode.READ_ONLY
    )
    private String senderName;

    @Schema(
            description = "Notification message content",
            example = "You have a new connection request",
            maxLength = 500,
            accessMode = Schema.AccessMode.READ_ONLY
    )
    private String message;

    @Schema(
            description = "Current status of the notification",
            example = "UNREAD",
            allowableValues = {"READ", "UNREAD"},
            accessMode = Schema.AccessMode.READ_ONLY
    )
    private String status;

    @Schema(
            description = "Timestamp when the notification was created",
            example = "2023-05-15T14:30:45",
            accessMode = Schema.AccessMode.READ_ONLY
    )
    private LocalDateTime createdAt;

    public NotificationResponse(Long id, Long senderId, String senderName, String message, String status, LocalDateTime createdAt) {
        this.id = id;
        this.senderId = senderId;
        this.senderName = senderName;
        this.message = message;
        this.status = status;
        this.createdAt = createdAt;
    }
}

===== .\dto\PostResponse.java =====

package com.divya.linkedinclone.dto;

import com.divya.linkedinclone.entity.Post;
import com.divya.linkedinclone.entity.User;
import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;

@Getter
@Setter
@Schema(description = "Response object representing a post with author details")
public class PostResponse {

    @Schema(
            description = "Unique identifier of the post",
            example = "1",
            accessMode = Schema.AccessMode.READ_ONLY
    )
    private Long id;

    @Schema(
            description = "Text content of the post",
            example = "Check out this amazing new feature we launched!",
            maxLength = 2000,
            accessMode = Schema.AccessMode.READ_ONLY
    )
    private String content;

    @Schema(
            description = "Timestamp when the post was created",
            example = "2023-05-15T10:30:00",
            accessMode = Schema.AccessMode.READ_ONLY
    )
    private LocalDateTime createdAt;

    @Schema(
            description = "Timestamp when the post was last updated",
            example = "2023-05-15T11:45:00",
            accessMode = Schema.AccessMode.READ_ONLY
    )
    private LocalDateTime updatedAt;

    @Schema(
            description = "Path to the post's image if available",
            example = "/uploads/posts/123-image.jpg",
            nullable = true,
            accessMode = Schema.AccessMode.READ_ONLY
    )
    private String imagePath;

    @Schema(
            description = "Author details of the post",
            accessMode = Schema.AccessMode.READ_ONLY
    )
    private UserResponse user;

    @Getter
    @Setter
    @Schema(description = "Nested user information")
    public static class UserResponse {
        @Schema(
                description = "User ID of the post author",
                example = "101",
                accessMode = Schema.AccessMode.READ_ONLY
        )
        private Long id;

        @Schema(
                description = "Name of the post author",
                example = "John Doe",
                accessMode = Schema.AccessMode.READ_ONLY
        )
        private String name;

        @Schema(
                description = "Email of the post author",
                example = "john.doe@example.com",
                accessMode = Schema.AccessMode.READ_ONLY
        )
        private String email;

        public UserResponse(User user) {
            this.id = user.getId();
            this.name = user.getName();
            this.email = user.getEmail();
        }
    }

    public PostResponse(Post post) {
        this.id = post.getId();
        this.content = post.getContent();
        this.createdAt = post.getCreatedAt();
        this.updatedAt = post.getUpdatedAt();
        this.imagePath = post.getImagePath();
        this.user = new UserResponse(post.getUser());
    }
}

===== .\dto\UserRegistrationRequest.java =====

package com.divya.linkedinclone.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

@Schema(description = "Request object for registering a new user account")
public class UserRegistrationRequest {

    @Schema(
            description = "Full name of the user",
            example = "John Doe",
            required = true,
            minLength = 2,
            maxLength = 100
    )
    @NotBlank(message = "Name is required")
    private String name;

    @Schema(
            description = "Email address for the user account",
            example = "john.doe@example.com",
            required = true,
            format = "email",
            maxLength = 100
    )
    @NotBlank(message = "Email is required")
    @Email(message = "Invalid email format")
    private String email;

    @Schema(
            description = "Password for the user account",
            example = "SecurePassword123!",
            required = true,
            minLength = 8,
            maxLength = 50,
            format = "password"
    )
    @NotBlank(message = "Password is required")
    @Size(min = 8, message = "Password must be at least 8 characters long")
    private String password;

    // Getters and Setters
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}

===== .\entity\Comment.java =====

package com.divya.linkedinclone.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;

@Entity
@Getter
@Setter
@Table(name = "comments")
@EntityListeners(AuditingEntityListener.class)
public class Comment {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String content;

    @CreatedDate
    private LocalDateTime createdAt;

    @ManyToOne
    @JoinColumn(name = "post_id", nullable = false)
    private Post post;

    @ManyToOne
    @JoinColumn(name = "user_id", nullable = false)
    private User user;
}

===== .\entity\Connection.java =====

package com.divya.linkedinclone.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;

@Entity
@Getter
@Setter
@Table(name = "connections")
@EntityListeners(AuditingEntityListener.class)
public class Connection {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "sender_id", nullable = false)
    private User sender;

    @ManyToOne
    @JoinColumn(name = "receiver_id", nullable = false)
    private User receiver;

    @Enumerated(EnumType.STRING)
    private ConnectionStatus status = ConnectionStatus.PENDING;

    @CreatedDate
    private LocalDateTime createdAt;

    public enum ConnectionStatus {
        PENDING, CONNECTED, REJECTED
    }
}

===== .\entity\Follow.java =====

package com.divya.linkedinclone.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;

@Entity
@Getter
@Setter
@Table(name = "follows")
@EntityListeners(AuditingEntityListener.class)
public class Follow {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "follower_id", nullable = false)
    private User follower;

    @ManyToOne
    @JoinColumn(name = "following_id", nullable = false)
    private User following;

    @CreatedDate
    private LocalDateTime createdAt;
}

===== .\entity\Like.java =====

package com.divya.linkedinclone.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

@Entity
@Getter
@Setter
@Table(name = "likes")
public class Like {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "post_id", nullable = false)
    private Post post;

    @ManyToOne
    @JoinColumn(name = "user_id", nullable = false)
    private User user;
}

===== .\entity\Message.java =====

package com.divya.linkedinclone.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;

@Entity
@Getter
@Setter
@Table(name = "messages")
@EntityListeners(AuditingEntityListener.class)
public class Message {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "sender_id", nullable = false)
    private User sender;

    @ManyToOne
    @JoinColumn(name = "receiver_id", nullable = false)
    private User receiver;

    @Column(nullable = false) // Use "message" instead of "content"
    private String message; // Changed from "content" to "message"

    @CreatedDate
    private LocalDateTime sentAt;
}

===== .\entity\Notification.java =====

package com.divya.linkedinclone.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;

@Entity
@Getter
@Setter
@Table(name = "notifications")
@EntityListeners(AuditingEntityListener.class)
public class Notification {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "recipient_id", nullable = false)
    private User recipient;

    @ManyToOne
    @JoinColumn(name = "sender_id", nullable = false)
    private User sender;

    private String message;

    @Enumerated(EnumType.STRING)
    private NotificationStatus status = NotificationStatus.UNREAD;

    @CreatedDate
    private LocalDateTime createdAt;

    public enum NotificationStatus {
        UNREAD, READ
    }
}

===== .\entity\Post.java =====

package com.divya.linkedinclone.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import com.fasterxml.jackson.annotation.JsonIgnore;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;

@Entity
@Getter
@Setter
@Table(name = "posts")
@EntityListeners(AuditingEntityListener.class)
public class Post {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String content;

    @CreatedDate
    private LocalDateTime createdAt;

    @LastModifiedDate
    private LocalDateTime updatedAt;

    private String imagePath;

    @ManyToOne
    @JoinColumn(name = "user_id", nullable = false)
    @JsonIgnore
    private User user;
}

===== .\entity\Profile.java =====

package com.divya.linkedinclone.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import com.fasterxml.jackson.annotation.JsonIgnore;

@Entity
@Getter
@Setter
@Table(name = "profiles")
public class Profile {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String bio;
    private String profilePicture;
    private String skills;
    private String experience;
    private String education;
    private String location;
    private String website;

    // One-to-one relationship with User
    @OneToOne
    @JoinColumn(name = "user_id", referencedColumnName = "id")
    @JsonIgnore
    private User user;
}

===== .\entity\User.java =====

package com.divya.linkedinclone.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Getter;
import lombok.Setter;
import lombok.ToString;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import com.fasterxml.jackson.annotation.JsonIgnore;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

@Entity
@Getter
@Setter
@ToString
@Table(name = "users")
public class User implements UserDetails {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotBlank(message = "Name is required")
    private String name;

    @NotBlank(message = "Email is required")
    @Email(message = "Invalid email format")
    private String email;

    @NotBlank(message = "Password is required")
    @Size(min = 8, message = "Password must be at least 8 characters long")
    private String password;

    // One-to-one relationship with Profile
    @OneToOne(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    @JsonIgnore
    private Profile profile;

    // One-to-many relationship with Post
    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<Post> posts;

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return Collections.emptyList();
    }

    @Override
    public String getPassword() {
        return this.password;
    }

    @Override
    public String getUsername() {
        return this.email;
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return true;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        User user = (User) o;
        return id != null && id.equals(user.id);
    }

    @Override
    public int hashCode() {
        return getClass().hashCode();
    }
}

===== .\exception\CommentNotFoundException.java =====

package com.divya.linkedinclone.exception;

public class CommentNotFoundException extends RuntimeException {
    public CommentNotFoundException(String message) {
        super(message);
    }
}

===== .\exception\PostNotFoundException.java =====

package com.divya.linkedinclone.exception;

public class PostNotFoundException extends RuntimeException {
  public PostNotFoundException(String message) {
    super(message);
  }
}

===== .\exception\ProfileNotFoundException.java =====

package com.divya.linkedinclone.exception;

public class ProfileNotFoundException extends RuntimeException {
    public ProfileNotFoundException(String message) {
        super(message);
    }
}

===== .\exception\UserNotFoundException.java =====

package com.divya.linkedinclone.exception;

public class UserNotFoundException extends RuntimeException {
    public UserNotFoundException(String message) {
        super(message);
    }
}

===== .\filter\JwtRequestFilter.java =====

package com.divya.linkedinclone.filter;

import com.divya.linkedinclone.service.CustomUserDetailsService;
import com.divya.linkedinclone.util.JwtUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;

@Component
public class JwtRequestFilter extends OncePerRequestFilter {

    @Autowired
    private JwtUtil jwtUtil;

    @Autowired
    private CustomUserDetailsService customUserDetailsService;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
            throws ServletException, IOException {
        final String authorizationHeader = request.getHeader("Authorization");

        String username = null;
        String jwt = null;

        if (authorizationHeader != null && authorizationHeader.startsWith("Bearer ")) {
            jwt = authorizationHeader.substring(7);
            username = jwtUtil.extractUsername(jwt);
        }

        if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {
            UserDetails userDetails = this.customUserDetailsService.loadUserByUsername(username);
            if (jwtUtil.validateToken(jwt, userDetails)) {
                UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken =
                        new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
                usernamePasswordAuthenticationToken
                        .setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                SecurityContextHolder.getContext().setAuthentication(usernamePasswordAuthenticationToken);
            }
        }
        chain.doFilter(request, response);
    }
}


===== .\repository\CommentRepository.java =====

package com.divya.linkedinclone.repository;

import com.divya.linkedinclone.entity.Comment;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface CommentRepository extends JpaRepository<Comment, Long> {
    List<Comment> findByPostId(Long postId);
}

===== .\repository\ConnectionRepository.java =====

package com.divya.linkedinclone.repository;

import com.divya.linkedinclone.entity.Connection;
import com.divya.linkedinclone.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface ConnectionRepository extends JpaRepository<Connection, Long> {
    Optional<Connection> findBySenderAndReceiver(User sender, User receiver);
    List<Connection> findByReceiverAndStatus(User receiver, Connection.ConnectionStatus status);
    List<Connection> findBySenderOrReceiver(User sender, User receiver);
    List<Connection> findBySender(User sender);
    List<Connection> findByReceiver(User receiver);
}

===== .\repository\FollowRepository.java =====

package com.divya.linkedinclone.repository;

import com.divya.linkedinclone.entity.Follow;
import com.divya.linkedinclone.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface FollowRepository extends JpaRepository<Follow, Long> {
    Optional<Follow> findByFollowerAndFollowing(User follower, User following);
    List<Follow> findByFollower(User follower);
    List<Follow> findByFollowing(User following);
}

===== .\repository\LikeRepository.java =====

package com.divya.linkedinclone.repository;

import com.divya.linkedinclone.entity.Like;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface LikeRepository extends JpaRepository<Like, Long> {
    Optional<Like> findByPostIdAndUserId(Long postId, Long userId);
    Long countByPostId(Long postId);
}

===== .\repository\MessageRepository.java =====

package com.divya.linkedinclone.repository;

import com.divya.linkedinclone.entity.Message;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface MessageRepository extends JpaRepository<Message, Long> {
    List<Message> findBySenderIdAndReceiverId(Long senderId, Long receiverId);
    List<Message> findBySenderIdOrReceiverId(Long userId1, Long userId2);
}

===== .\repository\NotificationRepository.java =====

package com.divya.linkedinclone.repository;

import com.divya.linkedinclone.entity.Notification;
import com.divya.linkedinclone.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface NotificationRepository extends JpaRepository<Notification, Long> {
    List<Notification> findByRecipientAndStatus(User recipient, Notification.NotificationStatus status);
    List<Notification> findByRecipient(User recipient);
}

===== .\repository\PostRepository.java =====

package com.divya.linkedinclone.repository;

import com.divya.linkedinclone.entity.Post;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface PostRepository extends JpaRepository<Post, Long> {
    List<Post> findByUserId(Long userId);
}

===== .\repository\ProfileRepository.java =====

package com.divya.linkedinclone.repository;

import com.divya.linkedinclone.entity.Profile;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface ProfileRepository extends JpaRepository<Profile, Long> {
    Optional<Profile> findByUserId(Long userId);
}

===== .\repository\UserRepository.java =====

package com.divya.linkedinclone.repository;

import com.divya.linkedinclone.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByEmail(String email);
}


===== .\service\CommentService.java =====

package com.divya.linkedinclone.service;

import com.divya.linkedinclone.entity.Comment;
import com.divya.linkedinclone.entity.Post;
import com.divya.linkedinclone.entity.User;
import com.divya.linkedinclone.exception.PostNotFoundException;
import com.divya.linkedinclone.exception.UserNotFoundException;
import com.divya.linkedinclone.repository.CommentRepository;
import com.divya.linkedinclone.repository.PostRepository;
import com.divya.linkedinclone.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import com.divya.linkedinclone.exception.CommentNotFoundException;
import java.util.List;

@Service
public class CommentService {

    @Autowired
    private CommentRepository commentRepository;

    @Autowired
    private PostRepository postRepository;

    @Autowired
    private UserRepository userRepository;

    public Comment addComment(Long postId, Long userId, String content) {
        Post post = postRepository.findById(postId)
                .orElseThrow(() -> new PostNotFoundException("Post not found with id: " + postId));
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException("User not found with id: " + userId));

        Comment comment = new Comment();
        comment.setContent(content);
        comment.setPost(post);
        comment.setUser(user);

        return commentRepository.save(comment);
    }

    public List<Comment> getCommentsByPostId(Long postId) {
        return commentRepository.findByPostId(postId);
    }

    public void deleteComment(Long commentId) {
        if (!commentRepository.existsById(commentId)) {
            throw new CommentNotFoundException("Comment not found with id: " + commentId);
        }
        commentRepository.deleteById(commentId);
    }
}

===== .\service\ConnectionService.java =====

package com.divya.linkedinclone.service;

import com.divya.linkedinclone.entity.Connection;
import com.divya.linkedinclone.entity.User;
import com.divya.linkedinclone.exception.UserNotFoundException;
import com.divya.linkedinclone.repository.ConnectionRepository;
import com.divya.linkedinclone.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import java.util.stream.Collectors;
import java.util.List;
import java.util.Optional;
import com.divya.linkedinclone.dto.ConnectionResponse;

@Service
public class ConnectionService {

    @Autowired
    private ConnectionRepository connectionRepository;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private NotificationService notificationService; // Add this line


    public String sendConnectionRequest(Long senderId, Long receiverId) {
        User sender = userRepository.findById(senderId)
                .orElseThrow(() -> new UserNotFoundException("Sender user not found with id: " + senderId));
        User receiver = userRepository.findById(receiverId)
                .orElseThrow(() -> new UserNotFoundException("Receiver user not found with id: " + receiverId));

        Optional<Connection> existingConnection = connectionRepository.findBySenderAndReceiver(sender, receiver);
        if (existingConnection.isPresent()) {
            return "Connection request already sent.";
        }

        Connection connection = new Connection();
        connection.setSender(sender);
        connection.setReceiver(receiver);
        connection.setStatus(Connection.ConnectionStatus.PENDING);
        connectionRepository.save(connection);

        // Create a notification for the receiver
        notificationService.createNotification(receiverId, senderId, "You have a new connection request from " + sender.getName());

        return "Connection request sent successfully.";
    }

    public String acceptConnectionRequest(Long receiverId, Long senderId) {
        User receiver = userRepository.findById(receiverId)
                .orElseThrow(() -> new UserNotFoundException("Receiver user not found with id: " + receiverId));
        User sender = userRepository.findById(senderId)
                .orElseThrow(() -> new UserNotFoundException("Sender user not found with id: " + senderId));

        Connection connection = connectionRepository.findBySenderAndReceiver(sender, receiver)
                .orElseThrow(() -> new RuntimeException("Connection request not found."));

        connection.setStatus(Connection.ConnectionStatus.CONNECTED);
        connectionRepository.save(connection);

        // Create a notification for the sender
        notificationService.createNotification(senderId, receiverId, receiver.getName() + " accepted your connection request.");

        return "Connection request accepted. You are now connected!";
    }

    public String rejectConnectionRequest(Long receiverId, Long senderId) {
        User receiver = userRepository.findById(receiverId)
                .orElseThrow(() -> new UserNotFoundException("Receiver user not found with id: " + receiverId));
        User sender = userRepository.findById(senderId)
                .orElseThrow(() -> new UserNotFoundException("Sender user not found with id: " + senderId));

        Connection connection = connectionRepository.findBySenderAndReceiver(sender, receiver)
                .orElseThrow(() -> new RuntimeException("Connection request not found."));

        connection.setStatus(Connection.ConnectionStatus.REJECTED);
        connectionRepository.save(connection);

        // Create a notification for the sender
        notificationService.createNotification(senderId, receiverId, receiver.getName() + " rejected your connection request.");

        return "Connection request rejected.";
    }

    public String cancelConnectionRequest(Long senderId, Long receiverId) {
        User sender = userRepository.findById(senderId)
                .orElseThrow(() -> new UserNotFoundException("Sender user not found with id: " + senderId));
        User receiver = userRepository.findById(receiverId)
                .orElseThrow(() -> new UserNotFoundException("Receiver user not found with id: " + receiverId));

        Connection connection = connectionRepository.findBySenderAndReceiver(sender, receiver)
                .orElseThrow(() -> new RuntimeException("Connection request not found."));

        connectionRepository.delete(connection);

        return "Connection request canceled.";
    }

    public String removeConnection(Long userId, Long connectionId) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException("User not found with id: " + userId));
        User connectionUser = userRepository.findById(connectionId)
                .orElseThrow(() -> new UserNotFoundException("Connection user not found with id: " + connectionId));

        // Find the connection between the two users
        Optional<Connection> connection = connectionRepository.findBySenderAndReceiver(user, connectionUser);
        if (connection.isEmpty()) {
            connection = connectionRepository.findBySenderAndReceiver(connectionUser, user);
        }

        if (connection.isEmpty()) {
            throw new RuntimeException("Connection not found.");
        }

        connectionRepository.delete(connection.get());
        return "Connection removed successfully.";
    }

    public List<ConnectionResponse> getPendingRequests(Long userId) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException("User not found with id: " + userId));
        List<Connection> pendingConnections = connectionRepository.findByReceiverAndStatus(user, Connection.ConnectionStatus.PENDING);
        return pendingConnections.stream()
                .map(connection -> new ConnectionResponse(
                        connection.getSender().getId(),
                        connection.getSender().getName(),
                        connection.getStatus().toString()
                ))
                .collect(Collectors.toList());
    }

    public List<ConnectionResponse> getMutualConnections(Long userId, Long otherUserId) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException("User not found with id: " + userId));
        User otherUser = userRepository.findById(otherUserId)
                .orElseThrow(() -> new UserNotFoundException("Other user not found with id: " + otherUserId));

        List<Connection> userConnections = connectionRepository.findBySenderOrReceiver(user, user);
        List<Connection> otherUserConnections = connectionRepository.findBySenderOrReceiver(otherUser, otherUser);

        // Find mutual connections
        return userConnections.stream()
                .filter(connection -> otherUserConnections.contains(connection))
                .map(connection -> {
                    User connectedUser = connection.getSender().equals(user) ? connection.getReceiver() : connection.getSender();
                    return new ConnectionResponse(connectedUser.getId(), connectedUser.getName(), connection.getStatus().toString());
                })
                .collect(Collectors.toList());
    }

    public List<ConnectionResponse> getAllConnections(Long userId) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException("User not found with id: " + userId));
        List<Connection> connections = connectionRepository.findBySenderOrReceiver(user, user);
        return connections.stream()
                .map(connection -> {
                    User connectedUser = connection.getSender().equals(user) ? connection.getReceiver() : connection.getSender();
                    return new ConnectionResponse(connectedUser.getId(), connectedUser.getName(), connection.getStatus().toString());
                })
                .collect(Collectors.toList());
    }
}

===== .\service\CustomUserDetailsService.java =====

package com.divya.linkedinclone.service;

import com.divya.linkedinclone.entity.User;
import com.divya.linkedinclone.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import java.util.Collections;

@Service
public class CustomUserDetailsService implements UserDetailsService {

    @Autowired
    private UserRepository userRepository;

    @Override
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
        User user = userRepository.findByEmail(email)
                .orElseThrow(() -> new UsernameNotFoundException("User not found with email: " + email));
        return new org.springframework.security.core.userdetails.User(
                user.getEmail(), user.getPassword(), Collections.emptyList());
    }
}


===== .\service\FollowService.java =====

package com.divya.linkedinclone.service;

import com.divya.linkedinclone.entity.Follow;
import com.divya.linkedinclone.entity.User;
import com.divya.linkedinclone.exception.UserNotFoundException;
import com.divya.linkedinclone.repository.FollowRepository;
import com.divya.linkedinclone.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
public class FollowService {

    @Autowired
    private FollowRepository followRepository;

    @Autowired
    private UserRepository userRepository;

    public String followUser(Long followerId, Long followingId) {
        User follower = userRepository.findById(followerId)
                .orElseThrow(() -> new UserNotFoundException("Follower user not found with id: " + followerId));
        User following = userRepository.findById(followingId)
                .orElseThrow(() -> new UserNotFoundException("Following user not found with id: " + followingId));

        Optional<Follow> existingFollow = followRepository.findByFollowerAndFollowing(follower, following);
        if (existingFollow.isPresent()) {
            return "You are already following this user";
        }

        Follow follow = new Follow();
        follow.setFollower(follower);
        follow.setFollowing(following);
        followRepository.save(follow);

        return "You are now following user " + followingId;
    }

    public String unfollowUser(Long followerId, Long followingId) {
        User follower = userRepository.findById(followerId)
                .orElseThrow(() -> new UserNotFoundException("Follower user not found with id: " + followerId));
        User following = userRepository.findById(followingId)
                .orElseThrow(() -> new UserNotFoundException("Following user not found with id: " + followingId));

        Optional<Follow> existingFollow = followRepository.findByFollowerAndFollowing(follower, following);
        if (existingFollow.isEmpty()) {
            return "You are not following this user";
        }

        followRepository.delete(existingFollow.get());
        return "You have unfollowed user " + followingId;
    }

    public List<Long> getFollowers(Long userId) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException("User not found with id: " + userId));
        return followRepository.findByFollowing(user).stream()
                .map(follow -> follow.getFollower().getId())
                .collect(Collectors.toList());
    }

    public List<Long> getFollowing(Long userId) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException("User not found with id: " + userId));
        return followRepository.findByFollower(user).stream()
                .map(follow -> follow.getFollowing().getId())
                .collect(Collectors.toList());
    }
}

===== .\service\LikeService.java =====

package com.divya.linkedinclone.service;

import com.divya.linkedinclone.entity.Like;
import com.divya.linkedinclone.entity.Post;
import com.divya.linkedinclone.entity.User;
import com.divya.linkedinclone.exception.PostNotFoundException;
import com.divya.linkedinclone.exception.UserNotFoundException;
import com.divya.linkedinclone.repository.LikeRepository;
import com.divya.linkedinclone.repository.PostRepository;
import com.divya.linkedinclone.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import com.divya.linkedinclone.dto.LikeResponse;
import java.util.Optional;

@Service
public class LikeService {

    @Autowired
    private LikeRepository likeRepository;

    @Autowired
    private PostRepository postRepository;

    @Autowired
    private UserRepository userRepository;

    public LikeResponse toggleLike(Long postId, Long userId) {
        Post post = postRepository.findById(postId)
                .orElseThrow(() -> new PostNotFoundException("Post not found with id: " + postId));
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException("User not found with id: " + userId));

        Optional<Like> existingLike = likeRepository.findByPostIdAndUserId(postId, userId);

        if (existingLike.isPresent()) {
            likeRepository.delete(existingLike.get());
        } else {
            Like like = new Like();
            like.setPost(post);
            like.setUser(user);
            likeRepository.save(like);
        }

        Long likeCount = likeRepository.countByPostId(postId);
        return new LikeResponse(postId, userId, likeCount);
    }

    public Long getLikeCount(Long postId) {
        if (!postRepository.existsById(postId)) {
            throw new PostNotFoundException("Post not found with id: " + postId);
        }
        return likeRepository.countByPostId(postId);
    }
}

===== .\service\MessageService.java =====

package com.divya.linkedinclone.service;

import com.divya.linkedinclone.entity.Message;
import com.divya.linkedinclone.entity.User;
import com.divya.linkedinclone.exception.UserNotFoundException;
import com.divya.linkedinclone.repository.MessageRepository;
import com.divya.linkedinclone.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import com.divya.linkedinclone.dto.MessageResponse;
import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class MessageService {

    @Autowired
    private MessageRepository messageRepository;

    @Autowired
    private UserRepository userRepository;

    public Message sendMessage(Long senderId, Long receiverId, String message) {
        User sender = userRepository.findById(senderId)
                .orElseThrow(() -> new UserNotFoundException("Sender not found with id: " + senderId));
        User receiver = userRepository.findById(receiverId)
                .orElseThrow(() -> new UserNotFoundException("Receiver not found with id: " + receiverId));

        Message newMessage = new Message();
        newMessage.setSender(sender);
        newMessage.setReceiver(receiver);
        newMessage.setMessage(message); // Ensure this is correctly defined
        newMessage.setSentAt(LocalDateTime.now());

        return messageRepository.save(newMessage); // Return the Message entity
    }

    public List<MessageResponse> getConversation(Long userId1, Long userId2) {
        List<Message> messages = messageRepository.findBySenderIdAndReceiverId(userId1, userId2);
        messages.addAll(messageRepository.findBySenderIdAndReceiverId(userId2, userId1));

        return messages.stream()
                .map(message -> new MessageResponse(
                        message.getId(),
                        message.getSender().getId(),
                        message.getReceiver().getId(),
                        message.getMessage(), // Changed from "getContent" to "getMessage"
                        message.getSentAt()
                ))
                .collect(Collectors.toList());
    }

    public List<MessageResponse> getAllConversations(Long userId) {
        List<Message> messages = messageRepository.findBySenderIdOrReceiverId(userId, userId);

        return messages.stream()
                .map(message -> new MessageResponse(
                        message.getId(),
                        message.getSender().getId(),
                        message.getReceiver().getId(),
                        message.getMessage(), // Changed from "getContent" to "getMessage"
                        message.getSentAt()
                ))
                .collect(Collectors.toList());
    }
}

===== .\service\NotificationService.java =====

package com.divya.linkedinclone.service;

import com.divya.linkedinclone.entity.Notification;
import com.divya.linkedinclone.entity.User;
import com.divya.linkedinclone.exception.UserNotFoundException;
import com.divya.linkedinclone.repository.NotificationRepository;
import com.divya.linkedinclone.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import com.divya.linkedinclone.dto.NotificationResponse;
import java.util.stream.Collectors;

import java.util.List;

@Service
public class NotificationService {

    @Autowired
    private NotificationRepository notificationRepository;

    @Autowired
    private UserRepository userRepository;

    // Create a new notification
    public Notification createNotification(Long recipientId, Long senderId, String message) {
        User recipient = userRepository.findById(recipientId)
                .orElseThrow(() -> new UserNotFoundException("Recipient user not found with id: " + recipientId));
        User sender = userRepository.findById(senderId)
                .orElseThrow(() -> new UserNotFoundException("Sender user not found with id: " + senderId));

        Notification notification = new Notification();
        notification.setRecipient(recipient);
        notification.setSender(sender);
        notification.setMessage(message);
        return notificationRepository.save(notification);
    }

    // Get all unread notifications for a user
    public List<NotificationResponse> getUnreadNotifications(Long userId) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException("User not found with id: " + userId));
        List<Notification> unreadNotifications = notificationRepository.findByRecipientAndStatus(user, Notification.NotificationStatus.UNREAD);
        return unreadNotifications.stream()
                .map(notification -> new NotificationResponse(
                        notification.getId(),
                        notification.getSender().getId(),
                        notification.getSender().getName(),
                        notification.getMessage(),
                        notification.getStatus().toString(),
                        notification.getCreatedAt()
                ))
                .collect(Collectors.toList());
    }

    // Get all notifications for a user
    public List<NotificationResponse> getAllNotifications(Long userId) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException("User not found with id: " + userId));
        List<Notification> allNotifications = notificationRepository.findByRecipient(user);
        return allNotifications.stream()
                .map(notification -> new NotificationResponse(
                        notification.getId(),
                        notification.getSender().getId(),
                        notification.getSender().getName(),
                        notification.getMessage(),
                        notification.getStatus().toString(),
                        notification.getCreatedAt()
                ))
                .collect(Collectors.toList());
    }

    // Mark a notification as read
    public void markNotificationAsRead(Long notificationId) {
        Notification notification = notificationRepository.findById(notificationId)
                .orElseThrow(() -> new RuntimeException("Notification not found with id: " + notificationId));
        notification.setStatus(Notification.NotificationStatus.READ);
        notificationRepository.save(notification);
    }
}

===== .\service\PostService.java =====

package com.divya.linkedinclone.service;

import com.divya.linkedinclone.entity.Post;
import com.divya.linkedinclone.entity.User;
import com.divya.linkedinclone.repository.PostRepository;
import com.divya.linkedinclone.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.multipart.MultipartFile;
import java.time.LocalDateTime;
import java.util.List;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.UUID;
import com.divya.linkedinclone.exception.PostNotFoundException;


@Service
public class PostService {

    @Autowired
    private PostRepository postRepository;

    @Autowired
    private UserRepository userRepository;


    @Value("${upload.directory}") // Define the upload directory in application.properties
    private String uploadDirectory;

    public Post createPostWithImage(Long userId, String content, MultipartFile image) throws IOException {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new RuntimeException("User not found"));

        // Save the image file
        String imagePath = saveImage(image);

        // Create and save the post
        Post post = new Post();
        post.setContent(content);
        post.setImagePath(imagePath);
        post.setCreatedAt(LocalDateTime.now());
        post.setUser(user);

        return postRepository.save(post);
    }

    private String saveImage(MultipartFile image) throws IOException {
        if (image.isEmpty()) {
            throw new RuntimeException("Image file is empty");
        }

        // Generate a unique file name
        String fileName = UUID.randomUUID().toString() + "_" + image.getOriginalFilename();

        // Create the upload directory if it doesn't exist
        Path uploadPath = Paths.get(uploadDirectory);
        if (!Files.exists(uploadPath)) {
            Files.createDirectories(uploadPath);
        }

        // Save the file to the upload directory
        Path filePath = uploadPath.resolve(fileName);
        Files.copy(image.getInputStream(), filePath);

        return filePath.toString();
    }


    // Create a new post
    public Post createPost(Long userId, String content) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new RuntimeException("User not found"));

        Post post = new Post();
        post.setContent(content);
        post.setCreatedAt(LocalDateTime.now());
        post.setUser(user);

        return postRepository.save(post);
    }


    // Get all posts by a user
    public List<Post> getPostsByUserId(Long userId) {
        if (!userRepository.existsById(userId)) {
            throw new RuntimeException("User not found");
        }
        return postRepository.findByUserId(userId);
    }

    // Get a specific post by ID
    public Post getPostById(Long postId) {
        return postRepository.findById(postId)
                .orElseThrow(() -> new PostNotFoundException("Post not found with id: " + postId));
    }
    public List<Post> getAllPosts() {
        return postRepository.findAll();
    }
    // Update a post
    public Post updatePost(Long postId, String newContent) {
        Post post = postRepository.findById(postId)
                .orElseThrow(() -> new RuntimeException("Post not found with id: " + postId));

        post.setContent(newContent); // Update the content
        return postRepository.save(post); // Save the updated post
    }
    // Delete a post by ID
    public void deletePost(Long postId) {
        if (!postRepository.existsById(postId)) {
            throw new RuntimeException("Post not found");
        }
        postRepository.deleteById(postId);
    }
}

===== .\service\ProfileService.java =====

package com.divya.linkedinclone.service;


import com.divya.linkedinclone.entity.Profile;
import com.divya.linkedinclone.entity.User;
import com.divya.linkedinclone.exception.UserNotFoundException;
import com.divya.linkedinclone.exception.ProfileNotFoundException;

import com.divya.linkedinclone.repository.ProfileRepository;
import com.divya.linkedinclone.repository.UserRepository;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class ProfileService {

    @Autowired
    private ProfileRepository profileRepository;

    @Autowired
    private UserRepository userRepository;

    // Create or update a profile for a user
    public Profile createOrUpdateProfile(Long userId, @Valid Profile profile) {
        // Check if a profile already exists for the user
        Profile existingProfile = profileRepository.findByUserId(userId).orElse(null);

        if (existingProfile != null) {
            // Update the existing profile
            existingProfile.setBio(profile.getBio());
            existingProfile.setProfilePicture(profile.getProfilePicture());
            existingProfile.setSkills(profile.getSkills());
            existingProfile.setExperience(profile.getExperience());
            existingProfile.setEducation(profile.getEducation());
            existingProfile.setLocation(profile.getLocation());
            existingProfile.setWebsite(profile.getWebsite());
            return profileRepository.save(existingProfile);
        } else {
            // Create a new profile
            User user = userRepository.findById(userId)
                    .orElseThrow(() -> new UserNotFoundException("User not found with id: " + userId));
            profile.setUser(user);
            return profileRepository.save(profile);
        }
    }

    // Get profile by user ID
    public Profile getProfileByUserId(Long userId) {
        return profileRepository.findByUserId(userId)
                .orElseThrow(() -> new RuntimeException("Profile not found for user id: " + userId));
    }

    // Delete profile by ID
    public void deleteProfile(Long id) {
        if (!profileRepository.existsById(id)) {
            throw new ProfileNotFoundException("Profile not found with id: " + id);
        }
        profileRepository.deleteById(id);
    }
}

===== .\service\UserService.java =====

package com.divya.linkedinclone.service;

import com.divya.linkedinclone.dto.UserRegistrationRequest;
import com.divya.linkedinclone.entity.Profile;
import com.divya.linkedinclone.entity.User;
import com.divya.linkedinclone.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;
import com.divya.linkedinclone.exception.UserNotFoundException;

import java.util.Collections;
import java.util.Optional;

@Service
public class UserService implements UserDetailsService {

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private PasswordEncoder passwordEncoder;

    @Autowired
    private ProfileService profileService; // Inject ProfileService

    // Register a new user
    public User registerUser(UserRegistrationRequest registrationRequest) {
        // Check if the email already exists
        if (userRepository.findByEmail(registrationRequest.getEmail()).isPresent()) {
            throw new UserNotFoundException("Email already exists");
        }

        // Create and save the User
        User user = new User();
        user.setName(registrationRequest.getName());
        user.setEmail(registrationRequest.getEmail());
        user.setPassword(passwordEncoder.encode(registrationRequest.getPassword()));

        User savedUser = userRepository.save(user);

        // Create and save the Profile with default values
        Profile profile = new Profile();
        profile.setBio(""); // Default empty bio
        profile.setProfilePicture(""); // Default empty profile picture
        profile.setSkills(""); // Default empty skills
        profile.setExperience(""); // Default empty experience
        profile.setEducation(""); // Default empty education
        profile.setLocation(""); // Default empty location
        profile.setWebsite(""); // Default empty website
        profile.setUser(savedUser); // Associate the profile with the user
        profileService.createOrUpdateProfile(savedUser.getId(), profile); // Save the profile

        return savedUser;
    }

    // Find a user by email
    public Optional<User> findByEmail(String email) {
        return userRepository.findByEmail(email);
    }

    // Load user details by email (required for authentication)
    @Override
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
        User user = userRepository.findByEmail(email)
                .orElseThrow(() -> new UsernameNotFoundException("User not found with email: " + email));

        // Ensure the password is BCrypt-encoded
        if (!user.getPassword().startsWith("$2a$")) {
            throw new UsernameNotFoundException("User password is not encoded with BCrypt");
        }

        // Return UserDetails object with the encoded password and authorities
        return new org.springframework.security.core.userdetails.User(
                user.getEmail(),
                user.getPassword(),
                Collections.emptyList() // Add roles/authorities if applicable
        );
    }
}

===== .\util\JwtUtil.java =====

package com.divya.linkedinclone.util;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.security.Keys;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Function;

@Component
public class JwtUtil {
    // Using Keys to generate a secure key
    private final SecretKey secretKey = Keys.secretKeyFor(SignatureAlgorithm.HS256);
    private static final long EXPIRATION_TIME = 864_000_000; // 10 days

    public String extractUsername(String token) {
        return extractClaim(token, Claims::getSubject);
    }

    public Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }

    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }

    private Claims extractAllClaims(String token) {
        return Jwts.parser()
                .verifyWith(secretKey)
                .build()
                .parseSignedClaims(token)
                .getPayload();
    }

    private Boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }

    public String generateToken(UserDetails userDetails) {
        Map<String, Object> claims = new HashMap<>();
        return createToken(claims, userDetails.getUsername());
    }

    private String createToken(Map<String, Object> claims, String subject) {
        return Jwts.builder()
                .claims(claims)
                .subject(subject)
                .issuedAt(new Date(System.currentTimeMillis()))
                .expiration(new Date(System.currentTimeMillis() + EXPIRATION_TIME))
                .signWith(secretKey)
                .compact();
    }

    public Boolean validateToken(String token, UserDetails userDetails) {
        final String username = extractUsername(token);
        return (username.equals(userDetails.getUsername()) && !isTokenExpired(token));
    }
}